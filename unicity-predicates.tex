\section{Predicates: Programmable Spending Conditions}\label{sec:predicates}

\subsection{Introduction}

Predicates generalize the concepts of token ownership and transfer in the Unicity infrastructure, which in Sections~\ref{sec:infrastructure}--\ref{sec:privacy} were defined via digital signatures as follows:
\begin{itemize}
\item \emph{Owner} -- a (legal/physical) person who controls the private key of a digital signature scheme
\item \emph{Ownership condition} -- the public key $\pubkey$ that corresponds to the private key of the owner.
\item \emph{Transfer} -- the owner presents a digital signature $\sigma$ on $m=H(\sthash,\txhash)$ (where $\sthash,\txhash$ are the state hash and the transaction hash, respectively) such that $\sigver(\pubkey,m,\sigma)=1$.
\end{itemize}
In this section, we present the following generalized concepts:
\begin{itemize}
\item \emph{Owner} -- an abstract group of (legal/physical) persons that together control the information necessary to create the next transaction with the token. The information may include private keys.
\item \emph{Ownership condition} -- a logical condition (predicate) $\predi$.
\item \emph{Transfer} -- the owner (as a group) presents a bit-string $\sigma$ such that the condition $\predi(\systime, m,\sigma)=1$ holds, where
$m=H(\sthash,\txhash)$ and $\systime$ is the \emph{system time} (an integer defined by the Unicity service). This means that predicates may also put restrictions on transaction execution time.
\end{itemize}
So far, we only have used predicates of type $\predi(\tau,m,\sigma)\equiv \sigver(\pubkey,m,\sigma)$, i.e.
all predicates $\predi$ are in the form $\sigver(\pubkey,\cdot,\cdot)$.

The predicates approach is certainly not new and is used already in the Bitcoin blockchain, where $\predi$ is called the \emph{locking script} and $\sigma$ is called the \emph{unlocking script} or \emph{witness}.

A typical example of a generalized predicate is the \emph{delayed execution} predicate defined by $\predi(\systime,m,\sigma)\equiv \mathsf{dex}_{\pubkey,\systime_0}(\systime,m,\sigma) \equiv (\systime\ge\tau_0)\;\wedge\; \sigver(\pubkey,m,\sigma)=1$, which states that the next transaction can be executed by the owner of the private key of $\pubkey$ not earlier than $\systime_0$. The delayed execution predicate is used in the protocols for inter-blockchain \emph{atomic swaps} between Bitcoin type blockchains.

It is a natural question whether the security properties (no double spending, no blocking, no association) will still hold in the Unicity infrastructure if the generalized predicates are in use. We will show shortly that double-spending is indeed impossible in the generalized scheme. However, the non-blocking condition is much less obvious.

The main concern is that arbitrarily chosen predicates do not have guaranteed security properties like the UF-CMA condition for digital signatures. For example, if a user chooses the ownership predicate $\predi(\systime,m,\sigma)\equiv (\sigma^2 - 2\sigma + 1=0)$ then anyone who is able to solve quadratic equations can make the next transfer with the token and hence, the no-blocking condition may seem to be violated. On the other hand, by intentionally  choosing such an ownership condition, the previous owner may indicate that the next abstract owner of the token is the group of all people who can efficiently solve quadratic equations, and in this sense, intuitively, the no blocking condition is not violated.

The predicates can also be chosen so that they cannot be solved (satisfied) in principle, i.e. they are logically inconsistent. For example
$\predi(\systime,m,\sigma)\equiv (\sigma^2 + 2\sigma + 1=0)$, where $\sigma$
is required to be real number, cannot be satisfied.

Another (less trivial) example of improper use of predicates is when a user applies one-time signature scheme as a many-times signature scheme. In this case, security-critical information leaks gradually so that an adversary, having triples
$(\systime_1,m_1,\sigma_1),\ldots,(\systime_n,m_n,\sigma_n)$ (so that $\predi(\systime_i,m_i,\sigma_i)=1$), can construct a new triple $(\systime,m,\sigma)$ such that $\predi(\systime,m,\sigma)=1$ and $m\not\in\{m_1,\ldots,m_n\}$.

Therefore, the precise mathematical formulation of the no-blocking condition -- \emph{only the owner of the private key of $\pubkey$ can block the state $S=(\pubkey,\sthash)$} -- must be revisited. We will redefine the no-blocking condition as follows -- \emph{only those who can solve the predicate $\predi$ can block the state $S=(\predi,\sthash)$}, where by solving $\predi$ we mean finding, for a given $m$, a pair $(\systime,\sigma)$ so that $\predi(\systime,m,\sigma)=1$.
In this paper, we will make this security definition precise and prove that it holds in the Unicity infrastructure. Intuitively, this means that undesired blocking can happen only because of the weakness of the user-chosen predicates and never because of the structural weakness of the Unicity infrastructure itself.

\subsection{Unicity Infrastructure with Predicates}

\subsubsection{Unicity Service}

Like in Section~\ref{sec:unicity-service} we model the Unicity Service as an ideal functionality, where we use \emph{system time} as an additional state variable.
The \emph{Unicity Service} $\unisrv$ is modeled as a state machine with state $(R,\systime)$, where:
\begin{itemize}
\item $R$ is a key-value store (dictionary), where both keys and values are of type $\bits{|k|}$. Initially, $R = \emptyset$. We will write $R[k] = \bot$ if there are no pairs $(k, v)$ stored in $R$.
\item $\systime$ is a non-negative integer called the \emph{system time}. Initially, $\systime=0$.
\end{itemize}
There are two types of inputs of $\unisrv$:
\begin{itemize}
\item A request $Q$ is a tuple $(\predi, \sthash, \txhash, \sigma)$, where:
\begin{itemize}
  \item $\predi$ is a predicate that represents the current abstract owner of a token, i.e. the owner before the transaction with the hash $\txhash$ is executed;
  \item $\sthash$ of type $\bits{k}$ is a state hash: the hash of the state of the token before the transaction is executed;
  \item $\txhash$ of type $\bits{k}$ is a transaction data hash (defined later);
  \item $\sigma$ of type $\bits{s}$ is a digital signature of the transaction.
 \end{itemize}
\item A \emph{new time} input message $\newtime$ that contains a non-negative integer $\systime_\mathsf{new}$.
\end{itemize}

\noindent The request $Q=(\predi,\sthash,\txhash,\sigma)$ is processed by $\unisrv$ with the state $(R,\systime)$ as follows:
\begin{enumerate}
\item If $R[H(\predi, \sthash)] = \bot$ and $\predi(\systime, H(\sthash, \txhash), \sigma) = 1$ then
\[
R \gets R \cup \{(H(\predi, \sthash), \txhash)\} \enspace,
\]
i.e. the new value of $R$ is defined by setting $R[H(\predi, \sthash)] \gets \txhash$ and leaving the rest of the contents of $R$ unchanged.
\item A proof $\pinc$ of the statement $R[H(\predi, \sthash)] = v$ (inclusion proof) is returned.
\end{enumerate}
During the normal work of the system, $\newtime$ is initiated by (and can only executed by) the consensus layer of the system. In attack scenarios, we will also give the adversary the access to the $\newtime$ functionality. This is for making the security conditions stronger. \medskip

\noindent The new time input $\newtime=(\systime_\mathsf{new})$ is processed by $\unisrv$ with the state $(R,\systime)$ as follows: If $\systime_\mathsf{new}>\systime$ then $\systime\gets \systime_\mathsf{new}$, i.e. the system time is updated if the new value is larger than the current value.
\medskip

\noindent It is easy to see that if $(R_0,\systime_0) = (\emptyset,0)$ is the initial state, $I_1, I_2, \ldots, I_n$ is any sequence of inputs (requests or new time inputs), $R_i$ is the dictionary after the input $I_i$, and $\systime_i$ is the system time after the input $I_i$, then:
\begin{itemize}
\item $\systime_0 \le \systime_1 \le \ldots \le \systime_n$, i.e.
the system time never decreases.
\item $R_0 \subseteq R_1 \subseteq \ldots \subseteq R_n$, i.e. the elements are never removed.
\item The state $R_n$ is a \emph{partial function}, i.e.
$\{(k, v), (k, v')\} \subseteq R$ implies $v = v'$.
\end{itemize}

We say that a key $k$ is \emph{blocked} if $R[k] \neq \bot$.

\subsubsection{Verification Function}

We assume that the inclusion proofs $\pinc$ contain the system time $\systime$, i.e. the value of $\systime$ when the corresponding new element was set in $R$. There is an extraction function $\exttime$ that
extracts the system time from the proof $\pinc$, i.e. $\systime\gets \exttime(\pinc)$.
We assume that the inclusion proofs $\pinc$ can be verified by any party using a verification function $\univer$ so that:
\begin{itemize}
\item If $\univer(k, v; \pinc) = 1$ then $R[k] = v$ in the current state $(R,\systime)$ of $\unisrv$. Hence, as $R$ is a partial function, for every $k, v, v', \pinc, \pinc'$, the following implication holds:
\begin{equation}\label{eq:eqtx-pred}
\univer(k, v; \pinc) = \univer(k, v'; \pinc') = 1 \quad \Rightarrow \quad v =v' \enspace.
\end{equation}
\item If $R[H(\predi, \sthash)] = \txhash$ after a request $\pinc \gets \unisrv(\predi, \sthash, \txhash, \sigma)$ to the Unicity Service, then $\univer(H(\predi, \sthash), \txhash, \pinc) = 1$.
\item If a request $\pinc\gets\unisrv(Q)$ was processed in the state $S=(R,\systime)$ that changes $R[H(\predi, \sthash)]$ from $\bot$ to $\neq\bot$, then $\exttime(\pinc)=\systime$.
\end{itemize}

\subsubsection{Transactions with a Token}

Every token has an abstract owner $A$ represented by a predicate $\predi$. We will call the pair $(\predi, \auxd)$ the \emph{state} of the token and $\sthash = H(\predi, \auxd)$ the state hash of the token.

The transaction payload (before certifying the transaction) with the token is a pair
$T = (\sthash, D)$, where:
\begin{enumerate}
\item $\sthash$ is the state hash before executing the transaction,
\item $D$ (transaction data) contains the following fields:
\begin{itemize}
\item $\predi'$: the predicate of the next abstract owner,
\item $x$: a uniformly chosen random string $x\gets\{0,1\}^\ell$,
\item $\auxd'$: other data for the next state.
\end{itemize}
\end{enumerate}

The pair $(\predi', \auxd')$ defines the next state of the token after executing the transaction $T$. The next state hash is $\sthash'=H(\sthash,x)$.
\medskip

\noindent\textbf{Certifying a transaction} $T = (\sthash, D)$ involves the following steps:
\begin{enumerate}
\item $(\txhash,d) \gets \commit(H(D))$ is computed using a perfectly hiding commitment scheme $(\setup,\commit,\open)$.
The commitment $\txhash$ is called the \emph{transaction data hash}.
\item The hash value $h_T = H(\sthash, \txhash)$ is computed.
\item A solution $\sigma$ is created such that $\predi(\systime_\mathsf{exp}, h_T, \sigma) = 1$ for an expected\footnote{In order to avoid failed certification calls, users could (1) query the current time from $\unisrv$ to
  minimize the difference, and (2) prioritize safety in predicate design. For example, the delayed
  execution predicate $\mathsf{dex}_{\pubkey,\tau_0}$ from the introduction uses an inequality
  $\systime \geq \tau_0$, which remains satisfiable for all future times.} value $\systime_\mathsf{exp}$ of system time.
\item The query $Q = (\predi,\sthash,\txhash,\sigma)$ is created.
\item $\unisrv$ is called to obtain $\pi\gets \unisrv(Q)$.
\item The certified transaction $(T,\sigma,\txhash,d,\pi)$ is formed.
\end{enumerate}

\noindent\textbf{Verifying a certified transaction} A certified transaction $(T,\sigma,\txhash,d,\pi)$ is verified in the state $(\predi,h)$ by the following algorithm:\medskip

\noindent $\certver(T,\sigma,\txhash,d,\pi;\predi,h)$:
If at least one of the following checks fail, return 0, otherwise return 1:
\begin{enumerate}
\item $T.\sthash=h$;
\item $\open(\txhash,d)=H(T.D)$;
\item $\predi(\exttime(\pi), H(\sthash,\txhash),\sigma)=1$;
\item $\univer(H(\predi,T.\sthash),\txhash,\pi)=1$.
\end{enumerate}

\begin{definition}[certification in a state]\label{de:certstate-pred}
A tuple $(T,\sigma,\txhash,d,\pi)$ is said to be \emph{certified in state} $(\predi,h)$ iff $\certver(T,\sigma,\txhash,d,\pi;\predi,h)=1$.
\end{definition}

Mint transactions are the same as in Section~\ref{sec:mint-transaction}, i.e. they do not use generalized predicates.

\subsubsection{Token Ledger}

A \emph{token ledger} is a sequence
\[
(T_0, \sigma_0, \pi_0; h^1_\mathsf{st}), (T_1, \sigma_1,\txhash^1,d_1,\pi_1; h^2_\mathsf{st}), \ldots, (T_n, \sigma_n, \txhash^n, d_n,\pi_n; h^{n+1}_\mathsf{st})
\]
where $(T_0, \sigma_0, \pi_0)$ is a certified mint transaction and for every index $i=1,\ldots, n$:
\begin{enumerate}
\item $(T_{i}, \sigma_{i}, \txhash^i,d_i, \pi_{i})$ is a certified transaction in the state $(T_{i-1}.D.\predi', h^{i}_\mathsf{st})$;
\item $h^{i}_\mathsf{st}=H(h^{i-1}_\mathsf{st},x_{i-1})$ where $x_{i-1} =T_{i-1}.D.x$.
\end{enumerate}

\subsection{Security}

Consider a token with the state $S = (\predi, \auxd)$. The transfer protocol ensures the following properties:
\begin{itemize}
\item \emph{No double-spending}:
Only one certified transaction can be created in the state $S$.
\item \emph{No association}: the Unicity service is unable to identify the transactions with the same token.
\item \emph{No blocking}:
Only the owner of the private key of $\predi$ can block the state $S = (\predi, \auxd)$ if it was not blocked before.
\end{itemize}

\noindent In this section, we present security proofs for all three properties. The proofs of no double-spending and no association are very similar to the proofs in Sections~\ref{sec:security}--\ref{sec:privacy}. The no blocking property
had to be modified to cover arbitrary predicates.

\subsubsection{Security against Double-Spending}

A double-spending adversary uses $\unisrv$ as an oracle. \medskip

\noindent\textbf{Double-spending scenario} involves the following steps:
\begin{enumerate}
\item $(T,\sigma,\txhash,d,\pinc),(T',\sigma',\txhash',d',\pinc'),(\predi,h)\gets A^\unisrv$.
\item The attack is successful iff $T\neq T'$ and
\begin{equation}\label{eq:dscond-pred}
\certver(T,\sigma,\txhash,d,\pinc;\predi,h)=\certver(T',\sigma',\txhash',d',\pinc';\predi,h)=1 \enspace.
\end{equation}
\end{enumerate}

\begin{definition}[Double-spending security]
The Unicity Service is said to be $S$-secure against double-spending if it has $S$ as a security profile in the double-spending scenario.
\end{definition}

\noindent\textbf{Analysis}: If the adversary is successful, then
from (\ref{eq:dscond-pred}) and the definition of $\certver$ it follows that
$T.\sthash = T'.\sthash=h$ and:
\begin{eqnarray*}
\univer(H(\predi, h), \txhash; \pinc) = \univer(H(\predi, h), \txhash'; \pinc') = 1\enspace,
\end{eqnarray*}
which implies $\txhash=\txhash'$ by equation~(\ref{eq:eqtx-pred}).
From Def.~\ref{de:certstate-pred} it also follows that
$\open(\txhash,d)=H(T.D)$ and $\open(\txhash,d')=\open(\txhash',d')=H(T'.D)$.
From $(h,T.D)=(T.\sthash,T.D)=T\neq T'=(T'.\sthash,T'.D)=(h,T'.D)$ it follows that $T.D\neq T'.D$. Hence, we have two cases:
\begin{itemize}
\item[a)] $H(T.D)=H(T'.D)$, which
means that a collision has been found for $H$.
\item[b)] $H(T.D)\neq H(T'.D)$, which implies $\open(\txhash,d)=H(T.D)\neq H(T'.D)=\open(\txhash,d')$ and hence, the commitment $\txhash$ has been opened in two different ways.
\end{itemize}

\begin{theorem}
If $H$ is $S$-secure collision-resistant and the commitment scheme is $S$-secure computationally binding, then the Unicity service is $S_\mathsf{double}$-secure against double-spending, where
$S_\mathsf{double}(\epsilon) = \frac{S(\epsilon/2)}{t_\mathsf{ver}+1}$
and $t_\mathsf{ver}$ is the predicate verification time.
\end{theorem}
\begin{proof}
Let $A$ be a $t$-time double-spending adversary that succeeds with probability $\epsilon$. We construct a collision-finder $A_\mathsf{coll}$ for the hash function and a double-opening adversary $A_\mathsf{com}$ for the commitment scheme as follows:
\begin{itemize}
\item $A_\mathsf{coll}$ proceeds as follows:
\begin{enumerate}
\item Simulate $(T,\sigma,\txhash,d,\pinc),(T',\sigma',\txhash',d',\pinc'),(\predi,h)\gets A^\unisrv$ by maintaining its own version of $\unisrv$.
\item Output the pair $(T.D,T'.D)$.
\end{enumerate}
The computational overhead function of $A_\mathsf{coll}$ is $\tau_\mathsf{coll}(t) = (t_\mathsf{ver}+1) \cdot t$, because simulating a $\unisrv$ query requires one signature verification and the number of calls is limited by the running time $t$ of $A$.
\item $A_\mathsf{com}$ proceeds as follows:
\begin{enumerate}
\item Simulate $(T,\sigma,\txhash,d,\pinc),(T',\sigma',\txhash',d',\pinc'),(\predi,h)\gets A^\unisrv$ by maintaining its own version of $\unisrv$.
\item Output the triple $(\txhash,d,d')$.
\end{enumerate}
The computational overhead function of $A_\mathsf{com}$ is the same as
that of $A_\mathsf{coll}$, i.e. $\tau_\mathsf{com}(t)= \tau_\mathsf{coll}(t)=(t_\mathsf{ver}+1) \cdot t$.
\end{itemize}
 If $A$ succeeds, then in case a) the collision finder $A_\mathsf{coll}$ succeeds, and in case b) the double-opener $A_\mathsf{com}$ succeeds. Hence, $\epsilon \le \epsilon_\mathsf{coll} + \epsilon_\mathsf{com}$, where $\epsilon_\mathsf{coll}$ is the success probability of $A_\mathsf{coll}$ and
$\epsilon_\mathsf{com}$ is the success probability of $A_\mathsf{com}$.
Therefore, the function $S_\mathsf{double}$ defined by
\[
S_\mathsf{double}(\epsilon) = \tau^{-1}_\mathsf{coll}(S(\epsilon/2)) =
\frac{S(\epsilon/2)}{t_\mathsf{ver}+1}
\]
is a security profile of the Unicity service against double-spending.
\end{proof}

\subsubsection{Security against Association}

The Association adversary $A=(A_1,A_2)$ is two-stage. \medskip

\noindent\textbf{Association scenario} involves the following steps:
\begin{enumerate}
\item $(\sthash, \predi', \auxd', a)\gets A_1$.
\item $x\gets \{0,1\}^\ell$.
\item $\sthash'\gets H(\sthash,x)$.
\item $\txhash\gets\commitc(H(\predi',x,\auxd')))$.
\item $x'\gets A_2(a; \sthash',\txhash)$.
\item The attack is successful iff $\sthash\in\{0,1\}^k$, $x'\in\{0,1\}^\ell$, and $H(\sthash,x')=\sthash'$. The success $\epsilon$ of $A$ is the probability that the attack is successful.
\end{enumerate}

\begin{definition}[association security]
The Unicity Service is said to be $S$-secure against association if it has $S$ as a security profile in the association scenario.
\end{definition}


\begin{theorem}
If the hash function is $S$-secure $(k,\ell)$-one-way and the commitment scheme is perfectly hiding, then the Unicity Service is $S_\mathsf{assoc}$-secure against association, where $S_\mathsf{assoc}(\epsilon)= S(\epsilon) - t_\mathsf{sm} - t_\mathsf{hash} - t_\mathsf{com}$, where
$t_\mathsf{sm}$, $t_\mathsf{hash}$, $t_\mathsf{com}$ are the random sampling time, the hashing time, and the commitment computation time, respectively.
\end{theorem}
\begin{proof}
Let $A=(A_1,A_2)$ be a $t$-time adversary that succeeds in the association scenario with probability $\epsilon$. Consider the following modified attack scenario:
\begin{enumerate}
\item $(\sthash, \predi', \auxd', a)\gets A_1$.
\item $x\gets \{0,1\}^\ell$.
\item $\sthash'\gets H(\sthash,x)$.
\item $x''\gets \{0,1\}^\ell$.
\item $\txhash'\gets\commitc(H(\predi',x'',\auxd')))$.
\item $x'\gets A_2(a; \sthash',\txhash')$.
\item The attack is successful iff $\sthash\in\{0,1\}^k$, $x'\in\{0,1\}^\ell$, and $H(\sthash,x')=\sthash'$.
\end{enumerate}
%For any fixed value of $L=(\sthash, \pubkey', \auxd', a)$, due to the perfect hiding, the probability distributions of $\txhash$ and $\txhash'$ are equal and due to Lemma~\ref{le:outputindependence} (by taking $g(x)=H(\pubkey',x,\auxd'))$), the random variables $\txhash$ and $\txhash'$ are both independent of $x$. This means that the arguments $(\sthash',\txhash)$ and $(\sthash',\txhash')$ of $A(a;\cdot)$ are equal
%in both scenarios, and hence $A$ succeeds in the modified scenario with probability $\epsilon$. We construct an adversary $A'=(A'_1,A'_2)$ as follows:

\noindent For any fixed value of $L=(\sthash, \predi', \auxd', a)$, due to perfect hiding, commitments $\txhash=\commitc(H(\predi',x,\auxd'))$ and $\txhash'=\commitc(H(\predi',x'',\auxd'))$ have equal probability distributions. Moreover, by Lemma~\ref{le:outputindependence} (with $g(x)=H(\predi',x,\auxd')$), the random variables $x$ and $\txhash=\commitc(H(\predi',x,\auxd'))$ are independent.

Since $x''$ and $x$ are independent, the commitment $\txhash'=\commitc(H(\predi',x'',\auxd'))$ is independent of both $x$ and $\sthash'=H(\sthash,x)$. Therefore, the joint distributions of $(\sthash',\txhash)$ and $(\sthash',\txhash')$ are equal, and hence $A$ succeeds in the modified scenario with probability $\epsilon$. We construct an adversary $A'=(A'_1,A'_2)$ as follows:
\begin{itemize}
\item $A'_1$ proceeds as follows:
\begin{enumerate}
\item $(\sthash, \predi', \auxd', a)\gets A_1$;
\item return $(\sthash, a')$, where $a'=(\predi', \auxd', a)$.
\end{enumerate}
\item $A'_2(a';y)$ with $a'=(\predi', \auxd', a)$ proceeds as follows:
\begin{enumerate}
\item $x''\gets \{0,1\}^\ell$;
\item $\txhash'\gets\commitc(H(\predi',x'',\auxd')))$;
\item $x'\gets A_2(a; y,\txhash')$;
\item return $x'$.
\end{enumerate}
\end{itemize}

\noindent The computational time overhead function of $A'$ is $\tau(t) = t + t_\mathsf{sm} + t_\mathsf{hash} + t_\mathsf{com}$ and hence, the function $S_\mathsf{assoc}$ defined by
\[
S_\mathsf{assoc}(\epsilon) = \tau^{-1}(S(\epsilon)) = S(\epsilon) - t_\mathsf{sm} - t_\mathsf{hash} - t_\mathsf{com}
\]
is a security profile of the Unicity service against association.
\end{proof}

\subsubsection{Security against Blocking}

By a predicate family we mean a pair $(\prgen,\prsig)$ of algorithms so that:
\begin{itemize}
\item $(\prikey,\predi)\gets\prgen$ generates a private key $\prikey$ and a predicate $\predi$.
\item $\prsig(\prikey,m)$ solves the predicate for $m$, i.e. either $\bot\gets\prsig(\prikey,m)$ (the solver gives up) or $(\systime,\sigma)\gets\prsig(\prikey,m)$ such that $\predi(\systime,m,\sigma)=1$.
\end{itemize}
The case $\bot\gets\prsig(\prikey,m)$ is necessary because the predicates can potentially be chosen so that they cannot be satisfied.

\medskip
\noindent A predicate solving adversary $A_\mathsf{solve}^\mathcal{O}$ for the predicate family $(\prgen,\prsig)$ uses an oracle $\mathcal{O}$
that uses (initially empty) dictionaries $\prikey[\iota]$, $\predi[\iota]$ as the state and answers to two types of queries:
\begin{itemize}
\item $\mathcal{O}(\mathsf{gen};\iota)$ -- a generation query that returns $\bot$ if $\predi[\iota]\neq \bot$, and otherwise generates $(\prikey,\predi)\gets\prgen$, sets $\prikey[\iota]\gets \prikey$, $\predi[\iota]\gets\predi$, and
returns $\predi$.
\item $\mathcal{O}(\mathsf{solve};\iota,m)$ -- a solving query that returns
$\bot$ if either $\predi[\iota]=\bot$ or $\prsig(\prikey[\iota],m)=\bot$, and otherwise, if $(\systime,\sigma)\gets \prsig(\prikey[\iota],m)$, it returns $(\systime,\sigma)$.
\end{itemize}
The predicate solving scenario involves the following steps:
\begin{enumerate}
\item $(\iota,\systime,m,\sigma)\gets A_\mathsf{solve}^\mathcal{O}$
\item The attack is successful if:
\begin{itemize}
\item[a)] $\predi[\iota]\neq\bot$, i.e. the query $\mathcal{O}(\mathsf{gen};\iota)$ was made by $A_\mathsf{solve}^\mathcal{O}$.
\item[b)] $\predi[\iota](\systime,m,\sigma)=1$
\item[c)] All queries of the form $\mathcal{O}(\mathsf{solve};\iota,m)$ made by  $A_\mathsf{solve}^\mathcal{O}$ (if there were any) were answered with $\bot$.
\end{itemize}
\end{enumerate}

\noindent A blocking adversary $A$ uses two oracles:
\begin{enumerate}
\item $\mathsf{US}$: the Unicity Service,
\item $\mathsf{TS}$: that uses (initially empty) dictionaries $\prikey[\iota]$, $\predi[\iota]$ as the state and answers to two types of queries:
\begin{itemize}
\item $\mathsf{TS}(\mathsf{gen};\iota)$ -- a generation query that returns $\bot$ if $\prikey[\iota]\neq \bot$, and otherwise generates $(\prikey,\predi)\gets\prgen$, sets $\prikey[\iota]\gets \prikey$, $\predi[\iota]\gets\predi$, and
returns $\predi$.
\item $\mathsf{TS}(\mathsf{solve};\iota,h,D)$ -- a solving query that returns
$\bot$ if either $\prikey[\iota]=\bot$ or $\prsig(\prikey[\iota],H(h,\txhash))=\bot$, and otherwise, returns $(\systime,\sigma, \txhash, d)$, where
$(\txhash, d)\gets \commit(H(D))$ and
$(\systime,\sigma)\gets \prsig(\prikey[\iota],H(h,\txhash))$.
\end{itemize}
\end{enumerate}

\noindent\textbf{Blocking scenario} involves the following steps:
\begin{enumerate}
\item $(\iota,\sthash)\gets A^{\mathsf{US},\mathsf{TS}}$
\item $A$ is successful if:
\begin{itemize}
\item[a)] $\predi[\iota]\neq\bot$
\item[b)] $R[H(\predi[\iota],\sthash)]\neq\bot$ after the scenario
\item[c)] No (successful) queries of the form $\mathsf{TS}(\mathsf{solve};\iota,\sthash,D)$ were made.
\end{itemize}
The success $\epsilon$ of $A$ is the probability that the attack is successful
\end{enumerate}

\noindent Note that if such a query was made, then the request $Q=(\predi[\iota],\sthash, \txhash,\sigma)$ to $\mathsf{US}$ at system time $\systime$ will trivially ensure $R[H(\predi[\iota],h_\mathsf{st})]\neq\bot$.
Note that the adversary can set the system time appropriately before the request $Q$. Hence, this is excluded by the security condition. \medskip

\begin{definition}[blocking security]
The Unicity Service is said to be $S$-secure against blocking if it has $S$ as a security profile in the blocking scenario.
\end{definition}

\noindent\textbf{Analysis}: The adversary $A$ can be successful in the following cases:
\begin{itemize}
\item[a)] A request $Q=(\predi', h'_\mathsf{st}, h_\mathsf{tx}, \sigma)$ with $(\predi',h'_\mathsf{st})\neq (\predi[\iota],h_\mathsf{st})$ to $\mathsf{US}$ enforces $R[H(\predi[\iota], h_\mathsf{st})]\neq\bot$, which means that  $H(\predi[\iota],h_\mathsf{st})=H(\predi', h'_\mathsf{st})$ and hence, a collision for $H$ was found.
\item[b)] A request $Q=(\predi[\iota], h_\mathsf{st}, h_\mathsf{tx}, \sigma)$ to $\mathsf{US}$ enforces $R[H(\predi[\iota], h_\mathsf{st})]\neq\bot$, which implies $\predi[\iota](\systime, H(h_\mathsf{st},h_\mathsf{tx}), \sigma)=1$ from the description of $\mathsf{US}$. Then we have two possibilities:
\begin{itemize}
\item[b1)] A query $(\systime',\sigma', \txhash', d)\gets\mathsf{TS}(\mathsf{solve};\iota,\sthash',D)$ was made such that the equality
$H(\sthash',\txhash')=H(\sthash,\txhash)$ holds. From the success condition of $A$ it follows that  $\sthash'\neq h_\mathsf{st}$ and we have a collision for $H$.
\item[b2)] If no queries $(\systime',\sigma', \txhash', d)\gets\mathsf{TS}(\mathsf{solve};\iota,\sthash',D)$ were made with $H(\sthash',\txhash')=H(\sthash,\txhash)$ then this means that $A$ was able to
solve the predicate family, i.e. for $m=H(\sthash,\txhash)$ finds $\tau,\sigma$
so that $\predi[\iota](\tau,m,\sigma)=1$ without using the predicate solving functionality.
\end{itemize}
\end{itemize}

\begin{theorem}
If the predicate family $(\prgen,\prsig)$ is $S$-secure against solving and the hash function is $S$-secure collision-resistant, then the Unicity service is
$S_\mathsf{block}$-secure against blocking, where $S_\mathsf{block}(\epsilon) =
\frac{S(\epsilon/2)}{\max\{t_\mathsf{gen}, t_\mathsf{sig}, t_\mathsf{ver},t_\mathsf{ver},t_\mathsf{com},t_\mathsf{hash}\}}$
and
$t_\mathsf{gen}$, $t_\mathsf{sig}$, $t_\mathsf{ver},t_\mathsf{com},t_\mathsf{hash}$ are the
key generation time (for $\prgen$), solving time (for $\prsig$), verification time (for $\predi$), commitment time, and hashing time, respectively.
\end{theorem}
\begin{proof}
Let $A$ be a $t$-time blocking adversary that succeeds with probability $\epsilon$. We construct a collision-finder $A_\mathsf{coll}$ and a
solver $A^\mathcal{O}_\mathsf{solve}$ as follows:
\begin{itemize}
\item $A_\mathsf{coll}$ proceeds as follows:
 \begin{enumerate}
   \item Simulates $(\iota,h_\mathsf{st})\gets A^{\mathsf{US},\mathsf{TS}}$ and records all the oracle queries.
   \item If $A^{\mathsf{US},\mathsf{TS}}$ was successful and either the case a) or b1) occurs, $A_\mathsf{coll}$ outputs the collision that is guaranteed in this case.
 \end{enumerate}
The oracles are simulated as follows:
 \begin{itemize}
   \item $\mathsf{US}$-queries: $A_\mathsf{coll}$ maintains its own version of $R$.
   \item $\mathsf{TS}$-queries: $A_\mathsf{coll}$ directly uses $\prgen$ and $\prsig$.
\end{itemize}
The computational time overhead function for the construction of $A_\mathsf{coll}$ is $\tau_\mathsf{coll}(t) = \max\{t_\mathsf{gen}, t_\mathsf{sig}, t_\mathsf{ver}\}\cdot t$, where
$t_\mathsf{ver}$ is the predicate verification time (for $\unisrv$-queries),
$t_\mathsf{sig}$ is the predicate solving time (for $\mathsf{TS}(\mathsf{solve};\cdot)$-queries), and $t_\mathsf{gen}$ is the generation time (for $\mathsf{TS}(\mathsf{gen};\cdot)$-queries).

\item $A_\mathsf{solve}^{\mathcal{O}}$ proceeds as follows:
 \begin{enumerate}
  \item Simulates $(\iota,h_\mathsf{st})\gets A^{\mathsf{US},\mathsf{TS}}$ and records all the oracle queries.
  \item If $A^{\mathsf{US},\mathsf{TS}}$ was successful and b2) occurs and $Q=(\predi', h_\mathsf{st}, h_\mathsf{tx}, \sigma)$ was the request that enforces $R[H(\predi[\iota], h_\mathsf{st})]\neq\bot$ at system time $\tau$ then:
  \begin{enumerate}
    \item[3.] $m\gets H(h_\mathsf{st}, h_\mathsf{tx})$.
    \item[4.] Output $(\iota,\tau,m,\sigma)$.
  \end{enumerate}
 \end{enumerate}
The oracles are simulated as follows:
 \begin{itemize}
  \item $\mathsf{US}$-queries are simulated so that $A_\mathsf{solve}^\mathcal{O}$ maintains its own version of $R$.
  \item $\mathsf{US}$-queries are simulated so that $A_\mathsf{solve}^\mathcal{O}$ maintains its own copy of the dictionary $\predi[]$ and processes the queries as follows:
  \begin{itemize}
      \item $\mathsf{TS}(\mathsf{gen};\iota)$ -- If $\predi[\iota]\neq \bot$ then return $\bot$. Otherwise, call $\predi[\iota]
      \gets\mathcal{O}(\mathsf{gen};\iota)$ and return $\predi[\iota]$.
      \item $\mathsf{TS}(\mathsf{solve};\iota,h,D)$ -- If $\predi[\iota]=\bot$ then return $\bot$. Otherwise, compute $(\txhash,d)\gets\commit(H(D))$, call $v\gets \mathcal{O}(\mathsf{solve};\iota, H(h,\txhash))$ and return $v$. Note that either $v=\bot$ or $v=(\systime,\sigma)$.
  \end{itemize}
 \end{itemize}
 As the request $Q$ was accepted by $\unisrv$ and it changes $R[H(\predi[\iota],\sthash)]$, we have $\predi'=\predi[\iota]$ (description of $\unisrv$) and
 $\predi[\iota](\systime,m,\sigma)=1$. Note that in the case b2) the request $\mathsf{TS}(\mathsf{solve}; \iota, \sthash,D)$ with $\open(\txhash,d)=H(D)$ was never made which also means that the query $\mathcal{O}(\mathsf{solve};\iota,m)$ with $m=H(\sthash,\txhash)$ was never made, and hence,
 $A_\mathsf{solve}^{\mathcal{O}}$ is successful in the predicate solving scenario. The computational time overhead function for the construction of $A_\mathsf{solve}^\mathcal{O}$ is
 \[
 \tau_\mathsf{solve}(t) = \max\{t_\mathsf{ver},t_\mathsf{com}\}\cdot t + t_\mathsf{hash}\le \max\{t_\mathsf{ver},t_\mathsf{com},t_\mathsf{hash}\}\cdot t\]
if $t\ge 1$, where
$t_\mathsf{ver}$ is the signature verification time (for $\unisrv$ queries), $t_\mathsf{com}$ is the commitment time (for $\mathsf{TS}(\mathsf{solve};\cdot)$-queries) and
$t_\mathsf{hash}$ is the hash computation time (for output).
\end{itemize}
If $A$ succeeds, then either $A_\mathsf{coll}$ or $A_\mathsf{solve}^\mathcal{O}$ succeeds and hence $\epsilon \le \epsilon_\mathsf{coll} + \epsilon_\mathsf{solve}$.
As for the function $\tau(t)=\max\{t_\mathsf{gen}, t_\mathsf{sig}, t_\mathsf{ver},t_\mathsf{ver},t_\mathsf{com},t_\mathsf{hash}\}\cdot t$ the inequalities $\tau_\mathsf{coll}(t)\le \tau(t)$
and $\tau_\mathsf{solve}(t)\le \tau(t)$ hold, we imply that
\[
S_\mathsf{block}(\epsilon) = \tau^{-1}(S(\epsilon/2)) =
\frac{S(\epsilon/2)}{\max\{t_\mathsf{gen}, t_\mathsf{sig}, t_\mathsf{ver},t_\mathsf{ver},t_\mathsf{com},t_\mathsf{hash}\}}
\]
is a security profile of the Unicity Service against blocking.
\end{proof}
