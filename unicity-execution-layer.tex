\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{pgf-umlsd} % sequence diagram
\usepackage{amssymb}
\usepackage{amsmath} % xleftarrow
\usepackage{enumitem}
\setlist[itemize]{noitemsep} % compact itemize
% \setlist[enumerate]{noitemsep}

\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]

\newenvironment{proof}{\textsf{Proof}.}{\hfill$\Box$}

\newcommand{\bits}[1]{\{0,1\}^{#1}}
\newcommand{\negl}[0]{\mathsf{negl}} % negligible quantity

\newcommand{\keygen}[0]{\mathsf{G}}
\newcommand{\sig}[0]{\mathsf{S}}
\newcommand{\sigver}[0]{\mathsf{V}}

\newcommand{\pubkey}[0]{\mathsf{pk}}
\newcommand{\prikey}[0]{\mathsf{sk}}

\newcommand{\hfgen}[0]{\mathsf{G}} % parameter generation for a hash function family
\newcommand{\hfunc}[0]{\mathsf{H}} % parametrized hashing algorithm

\newcommand{\setup}[0]{\mathsf{Set}}
\newcommand{\commit}[0]{\mathsf{Com}}
\newcommand{\open}[0]{\mathsf{Open}}
\newcommand{\commitc}[0]{\mathsf{Com}^{c}}

\newcommand{\param}[0]{\mathsf{par}}

\newcommand{\unisrv}[0]{\mathsf{US}}

\newcommand{\sthash}[0]{h_\mathsf{st}}
\newcommand{\txhash}[0]{h_\mathsf{tx}}

\newcommand{\auxd}[0]{\mathsf{aux}}

\newcommand{\univer}[0]{\mathcal{V}}

\newcommand{\certver}[0]{\mathcal{V}_\mathsf{cert}}

\newcommand{\pinc}[0]{\pi_{\mathsf{inc}}}

\newcommand{\prob}[0]{\mathsf{Pr}} % probability function

\title{ The Unicity Execution Layer }
\author{Ahto Buldas \and Ahto Truu \and Risto Laanoja \and Vladimir Rogojin}
\date{September 2025}

\begin{document}

\maketitle

\section{Introduction}

Blockchain technology has revolutionized digital asset management by enabling trustless peer-to-peer transactions without relying on centralized authorities. However, traditional blockchain architectures face fundamental scalability limitations that hinder their adoption for high-throughput applications. The core bottleneck stems from the fact that the ``security'' depends on the number of participating validators, which all have to participate in consensus on ordering, re-execute transactions, and store every produced block.

This paper introduces \emph{Unicity}, a novel blockchain infrastructure designed to enable secure off-chain transactions while maintaining the trustless guarantees of traditional blockchains. The key insight underlying Unicity is that the vast majority of blockchain operations—transaction execution, smart contract processing, and state transitions—can be moved off-chain, leaving only the essential double-spending prevention mechanism on-chain. This also simplifies on-chain operations, making efficient and self-authenticating implementations possible.

By minimizing the data that must be processed by the consensus layer, Unicity achieves linear scalability while preserving the security properties that make blockchains trustworthy. The system consists of three hierarchical layers: the Consensus Layer provides decentralized agreement and cryptoeconomical incentives, the Aggregation Layer maintains a distributed append-only dictionary of spent token states, and the Execution Layer handles peer-to-peer transaction processing and business logic.

Our approach differs fundamentally from existing scaling solutions. Rather than optimizing transaction throughput within the constraints of traditional blockchain architectures, Unicity reconceptualizes the shared server-side functionality as a minimal, trustless service which prevents double-spending. This architectural shift enables transactions to occur off-chain and, with hardware-based unicity-proving functionality, completely offline, while maintaining cryptographic guarantees against fraud.

The contributions of this paper include: (1) a formal security model for off-chain transactions with on-chain double-spending prevention, modeled as trusted service in this paper's scope, (2) cryptographic protocols ensuring transaction privacy and preventing attacks of blocking token spending, and (3) formal proofs of these security properties.

\subsection{Motivation}

\begin{figure}[!htbp]
 \begin{minipage}[h]{0.55\linewidth}
        \centering
                \includegraphics[width=\columnwidth]{pic/traditional.drawio}
                \caption{Data flow of a typical blockchain.} \label{fi:traditional}
    \end{minipage}
    \hfill
    \begin{minipage}[h]{0.44\linewidth}
        \centering
                \includegraphics[width=\columnwidth]{pic/unicity.drawio}
                \caption{Data flow of Unicity transactions.}\label{fi:unicity}
    \end{minipage}
\end{figure}

Traditional blockchain architectures, illustrated in Figure~\ref{fi:traditional}, require every validator node to process all transactions sequentially. This design creates several fundamental bottlenecks: (1) \emph{computational overhead} from validating every transaction, (2) \emph{storage requirements} that grow linearly with transaction history, and (3) \emph{bandwidth limitations} from broadcasting all transaction data to every node. These constraints result in throughput limitations measured in tens of transactions per second for major blockchain networks, and transaction processing latency (time to finality) which is not suitable for interactive use cases.

Existing scaling approaches attempt to optimize within these architectural constraints. Layer-2 solutions batch transactions but still require periodic settlement on the main chain. Sharding distributes computation but introduces complex cross-shard communication protocols. Both approaches face fundamental trade-offs between decentralization, security, and scalability.

Unicity takes a fundamentally different approach by recognizing that most blockchain operations can be moved off-chain and performed by the party who is naturally interested in the validity of the transaction, the recipient (relying party). The key insight is that central coordination is required only to prevent double-spending---the creation of multiple valid transactions spending the same digital asset. Other functions, including transaction execution, smart contract processing, state updates, and data availability, can be provided by interested parties without global agreement.

Figure~\ref{fi:unicity} illustrates the Unicity transaction flow. Rather than broadcasting full transaction data to all network participants, Unicity maintains only a cryptographic commitment to spent asset states.

Unicity as a transacting framework provides three essential guarantees: (1) \emph{unique spending}—a digital asset can be spent no more than once, (2) \emph{non-blocking}—only the legitimate owner of an asset can mark this asset as spent, and (3) \emph{privacy}—transaction details remain confidential between participants, hidden from the Unicity Service.

By decoupling transaction execution from consensus, Unicity enables new use cases previously impractical on traditional blockchains. Transactions can occur entirely off-chain, requiring no network connectivity at the time of execution. Multiple parties can transact directly using any communication channel, from internet protocols to physical media exchange. The resulting system scales linearly with the number of participants rather than facing the quadratic complexity growth of traditional blockchain networks.

\subsection{Unicity Protocol}

The Unicity execution framework relies on the \emph{Unicity Service} that maintains a global, append-only registry of spent token states. Each digital token has an associated state hash that uniquely identifies its current ownership and transaction history. When a token owner wishes to transfer ownership, they create a signed transaction that references the current state and specifies the new owner.

\subsubsection{System Architecture}

Unicity employs a hierarchical architecture that provides top-to-bottom decentralization and scalability, as illustrated in Figure~\ref{fig:layers}.

\begin{figure}[!htbp]
    \centering
        \begin{tikzpicture}
            \draw (0,0) rectangle (4,1) node[midway] {Consensus Layer};
            \draw (2,0) -- (2,-0.5);
            \draw (0,-1.5) rectangle (4,-0.5) node[midway] {Aggregation Layer};
            \draw[dashed] (1,-2) -- (3,-2);
            \draw (2,-1.5) -- (2,-2.5);
            \draw (0,-3.5) rectangle (4,-2.5) node[midway] {Execution Layer};
        \end{tikzpicture}
    \caption{Layered, hierarchical architecture of the Unicity Network.}\label{fig:layers}
\end{figure}

The three layers serve distinct functions:

\begin{itemize}
\item \textbf{Consensus Layer} provides decentralized agreement and finality through a combination of Proof-of-Work mining, providing robust decentralization, and BFT consensus with fast and deterministic finality. This layer verifies the integrity of the Aggregation Layer's state transitions and serves as the root of trust for the entire system.

\item \textbf{Aggregation Layer} implements the Unicity Service, maintaining a global append-only registry of spent token states. It provides inclusion and non-inclusion proofs, processes state certification requests, and with these services allows Execution Layer to avoid the risk of double-spending. The layer is sharded for scalability, clustered for high availability, and uses cryptographic consistency proofs to maintain trustless operation.

\item \textbf{Execution Layer} handles transaction processing, smart contract execution (implemented through orchestrated execution of programmable stateful spending conditions) and business logic. This layer operates off-chain and is managed by users and agents who are interested parties in transaction validation and ordering.
\end{itemize}

\subsubsection{Protocol Participants}

Within this architecture, the protocol involves three entities:

\begin{itemize}
\item \textbf{Token Owners} possess digital assets represented as tokens with unique state hashes. Owners sign transactions to transfer ownership and request certification from the Aggregation Layer.

\item \textbf{Unicity Service} (provided by the Aggregation Layer) maintains a data store, modeled in this paper as key-value store $R$ where keys are derived from public keys and state hashes, and values are transaction hashes. The service accepts certification requests and provides inclusion proofs for registered transactions.

\item \textbf{Recipients} are the relying parties who receive token transfers and must verify the authenticity of transactions cryptographically before accepting ownership.
\end{itemize}

\subsubsection{Transaction Structure}

Each transaction $T = (\sthash, D)$ consists of:
\begin{itemize}
\item $\sthash$: the current state hash of the token being transferred
\item $D = (\pubkey', x, \auxd)$: transaction data containing the recipient's public key $\pubkey'$, a random nonce $x$, and auxiliary data $\auxd$
\end{itemize}

\noindent To prevent information leakage, the transaction data $D$ is committed using a perfectly hiding commitment scheme, producing a transaction data hash $\txhash = \commitc(H(D))$. The sender signs $H(\sthash, \txhash)$ and submits a certification request $Q = (\pubkey, \sthash, \txhash, \sigma)$ to the Unicity Service.

\subsubsection{Double-Spending Prevention}

The Unicity Service processes certification requests by checking that (1) the digital signature is valid and (2) the key $H(\pubkey, \sthash)$ has not been previously registered. If both conditions hold, the service records the mapping $R[H(\pubkey, \sthash)] \gets \txhash$ and returns an inclusion proof $\pinc$. This mechanism ensures that each token state can be spent at most once.

Transaction flow is illustrated by the Sequence diagram (Fig.~\ref{fi:unicity-transaction}).

\begin{figure}[htb]
    \begin{center}
        \begin{sequencediagram}
            \newthread{S}{Sender}
            \newinst[2]{R}{Recipient}
            \newinst[2]{US}{Unicity Service}

            % Recipient generates keys and parameters
            \begin{call}{R}{Setup}{R}{}
            \end{call}

            % Recipient sends public key to sender
            \begin{messcall}{R}{$\pubkey'$}{S}
            \end{messcall}

            % Sender creates transaction data
            \begin{call}{S}{Prepare tx data}{S}{}
            \end{call}
            % Sender requests certification from Unicity Service
            \begin{messcall}{S}{$Q = (\pubkey, \sthash, \txhash, \sigma)$}{US}
                \begin{call}{US}{
                  Validate and set
                  %R[H(\pubkey, \sthash)] \gets \txhash$
                    }{US}{}
                \end{call}

            \end{messcall}
            \begin{messcall}{US}{$\pinc$}{S}
            \end{messcall}

            % Sender sends certified transaction to recipient
            \begin{messcall}{S}{$(T, \sigma, \txhash, d, \pinc)$}{R}
            \begin{call}{R}{Validate the tx}{R}{}
            \end{call}
            \end{messcall}

        \end{sequencediagram}
        \caption{Simplified Unicity transaction flow.}\label{fi:unicity-transaction}
    \end{center}
\end{figure}

The formal analysis that follows demonstrates that this construction provides strong security guarantees against both double-spending and blocking attacks while preserving transaction unlinkability.


\section{Preliminaries and Notation}

\subsection{Probabilities}

In the paper, we only use \emph{finite probability spaces} that are defined as pairs $(\Omega, \prob)$ so that $\Omega$ is a finite set and $\prob$ is a function from the powerset (the set of all subsets) of $\Omega$ to the interval $[0,1]$ of real numbers so that:
\begin{enumerate}
\item $\prob(\Omega)=1$
\item $\prob(A\cup B)=\prob(A) + \prob(B)$ for every $A,B\subseteq \Omega$ with $A\cap B=\emptyset$
\end{enumerate}

\noindent The set $\Omega$ is called the \emph{sample set} and $\prob$ is called the \emph{probability function}. The subsets of $\Omega$ are called \emph{events}. For the probability $\prob[\{\omega\}]$ of a singleton subset we use shorthand notation $\prob[\omega]$.
By a \emph{random variable} we mean any function $X\colon \Omega \rightarrow R$ where $R$ is called the \emph{range} of the random variable. If $x\in R$ we use the notation $\prob[X=x] = \prob[X^{-1}(x)]$, where $X^{-1}(x)=\{\omega\in\Omega\colon X(\omega)=x\}$ is the $X$-preimage of $x$.

As $\Omega$ is finite, we can express the probability $\prob(A)$ of any event $A$ as the sum $\prob[A]=\sum_\omega \prob[w]\cdot [w\in A]$, where
$[w\in A]$ is the \emph{Iverson symbol}, i.e. $[w\in A]\in\{0,1\}$ and $[w\in A]=1$ iff $w\in A$. We also use Iverson symbol in a more general case for any mathematical statements $\mathcal{A}$ so that $[\mathcal{A}]=1$ iff $\mathcal{A}$ holds. For example, $\prob[X=x]=\sum_\omega \prob[w]\cdot [X(w)=x]$. Note that $[\mathcal{A}\wedge \mathcal{B}]=[\mathcal{A}]\cdot[\mathcal{B}]$ for any two statements
$\mathcal{A}$ and $\mathcal{B}$.

By the \emph{probability distribution} of a random variable $X\colon \Omega \rightarrow R$ we mean the function $\mathcal{D}_X\colon R\rightarrow [0,1]$ such that $\mathcal{D}_X(x)=\prob[X=x]$ for every $x\in R$.
If $\mathcal{D}_X$ is a constant, i.e.
$\mathcal{D}_X(x)=\frac{1}{|R|}$ for every $x\in R$, then we say that the distribution is \emph{uniform}.
We use the notation $X\gets R$ to denote that $X$ is a uniformly distributed random variable with range $R$ and also say that $X$ is \emph{uniformly sampled} from $R$.
A random variable $X\colon \Omega \rightarrow R$ is \emph{$t$-time sampleable} if there is a $t$-time probabilistic Turing machine $\mathsf{M}$
with all outputs values in $R$ and every output value $x\gets \mathsf{M}$ occurs with probability $\mathcal{D}_X(x)$, i.e. the output distribution of
$\mathsf{M}$ is $\mathcal{D}_X$.


If $X\colon \Omega\rightarrow R_X$ and $Y\colon \Omega\rightarrow R_Y$ are
random variables, $x\in R_X$ and $y\in R_Y$, then we use the notation
$\prob[X=x, Y=y] = \prob[X^{-1}(x)\cap Y^{-1}(y)]=\sum_\omega \prob[\omega]\cdot[X(\omega)=x\,\wedge\, Y(\omega)=y]$.
The probability distribution $\mathcal{D}_{X,Y}\colon R_X \times R_Y\rightarrow [0,1]$ defined by $\mathcal{D}_{X,Y}(x,y)= \prob[X=x, Y=y]$ is called the \emph{joint distribution} of $X$ and $Y$.
We say that $X$ and $Y$ are \emph{independent} if
\[
\prob[X=x,Y=y]=\prob[X=x]\cdot\prob[Y=y]
\]
for every $x\in R_X$ and $y\in R_Y$.
If $(\Omega_1,\prob_1)$ and $(\Omega_2,\prob_2)$ are probability spaces, then their \emph{direct product} is the probability space $(\Omega, \prob)$, such that $\Omega = \Omega_1 \times \Omega_2$ and $\prob[\omega_1,\omega_2]=\prob_1[\omega_1]\cdot \prob_2[\omega_2]$ for every $\omega_1\in\Omega_1$ and $\omega_2\in\Omega_2$. We will omit the indices of the probability functions when it will not cause confusion.

\subsection{Security and Security Proofs}

A \emph{cryptographic primitive} is described as a list of (parametrized) algorithms, correctness conditions (invariants) and attack scenarios. Adversaries are algorithms that participate in the security scenarios (interacting with environment) and break (are successful in the attack scenario of) the primitive with certain \emph{success} (\emph{advantage}) $\epsilon\in[0,1]$, which often is the probability of a certain logical condition about the attack scenario.
If the parameters of a cryptographic primitive are fixed, we get an \emph{instance} of the primitive.

Every instance $f$ of a primitive has \emph{security profile}
which is a function $S_f\colon [0,1]\rightarrow \mathbb{N}$ that for every $\epsilon\in [0,1]$ returns a lower bound $S_f(\epsilon)$ of the running time of an adversary that is able to break the primitive with success at least $\epsilon$. Security profiles are non-decreasing, i.e.
$S_f(\epsilon)\le S_f(\epsilon')$ whenever $\epsilon\le \epsilon'$.
Therefore, every adversary that breaks a primitive $f$ with success $\epsilon$ has running time $t\ge S_f(\epsilon)$.

Sometimes an instance of a cryptographic primitive $g$ is constructed from instances $f_1, \ldots, f_m$ of other cryptographic primitives (using programming techniques).
A \emph{security reduction} (or \emph{security proof}) is a mathematical proof that the constructed primitive $g$ hash a security profile $S_g$
based on the security profiles $S_{f_1}, \ldots, S_{f_m}$ of $f_1, \ldots, f_m$, respectively.

Usually, in such a proof it is assumed that there is an adversary $A$ with running time $t$ that breaks $g$ with success $\epsilon$ and then the adversaries $A_1,\ldots, A_m$ are constructed based on $A$ that break $f_1,\ldots,f_m$ with (some unknown) successes  $\epsilon_1,\ldots,\epsilon_m$, respectively so that the inequality $\epsilon\le \epsilon_1 + \ldots + \epsilon_m$ holds.

Mostly, $A_1, \ldots, A_m$ use $A$ as black-box, i.e. either call or simulate $A$ and add some computational instructions. In this paper, we only have reductions where $A$ is called only once by every $A_i$ i.e. the running times of $A_1,\ldots,A_m$ are upper-bounded by $\tau_1(t), \ldots, \tau_m(t)$, respectively, where $\tau_i$ is the computational time overhead function for constructing $A_i$ from $A$.
Therefore, we have inequalities:
\[
\tau_1(t) \ge S_{f_1}(\epsilon_1), \quad \tau_2(t) \ge S_{f_2}(\epsilon_2), \quad \ldots\quad
\tau_m(t)\ge S_{f_m}(\epsilon_m)
\]
that imply $t\ge \min_{\epsilon_1 + \ldots + \epsilon_m = \epsilon}\max\{\tau^{-1}_1(S_{f_1}(\epsilon_1)), \ldots, \tau^{-1}_m(S_{f_m}(\epsilon_m))\}$, i.e. such reductions will prove the following security profile $S_g$ of $g$:
\begin{equation}\label{eq:lower}
S_g(\epsilon) = \min_{\epsilon_1 + \ldots + \epsilon_m = \epsilon}\max\{\tau^{-1}_1(S_{f_1}(\epsilon_1)), \ldots, \tau^{-1}_m(S_{f_m}(\epsilon_m))\}
\end{equation}
The minimum is necessary because we have to consider the worst distribution of $\epsilon_1,\ldots, \epsilon_m$ because the only fact we know about $\epsilon_i$ is that they are non-negative and their sum is $\epsilon$.
Equation (\ref{eq:lower}) implies a simpler but weaker profile $S'_g$:
\[
S'_g(\epsilon) = S_\mathsf{min}(\epsilon /m) =
 \min\{\tau^{-1}_1(S_{f_1}(\epsilon/m)), \ldots, \tau^{-1}_m(S_{f_m}(\epsilon/m))\}\enspace.
\]
Moreover, if $\tau(t)=\max\{\tau_1(t), \ldots, \tau_m(t)\}$ and $S_\mathsf{min}(\epsilon)= \min\{S_{f_1}(\epsilon), \ldots, S_{f_m}(\epsilon)\}$ then we have even simpler security profile $S''_g$ for $g$ defined by:
\begin{equation}\label{eq:losebound}
S''_g(\epsilon) = \tau^{-1}(S_\mathsf{min}(\epsilon/m))\enspace.
\end{equation}
In the security reductions of this paper, the time overhead function $\tau$ is linear, i.e. $\tau(t) = \alpha t + \beta$, where $\alpha$ and $\beta$ are reduction-specific constants.

\subsection{Signature Schemes}

A \emph{signature scheme} is a triple $(\keygen, \sig, \sigver)$ of algorithms such that:
\begin{itemize}
\item $(\pubkey, \prikey) \gets \keygen$ generates a public key $\pubkey$ and a private key $\prikey$
\item $\sigma \gets \sig(\prikey, m)$ generates a signature on a message $m$
\item $b \gets \sigver (\pubkey, m, \sigma)$ verifies a signature on a message (accepts if $b = 1$)
\end{itemize}
so that for every message $m$ the following \emph{verification identity} holds:
\[
\mathsf{Pr}[(\pubkey, \prikey) \gets \keygen \colon\; \sigver(\pubkey, m, \sig(\prikey, m)) = 1] = 1 \enspace.
\]

\begin{definition}[EF-CMA security]
A signature scheme $(\keygen, \sig, \sigver)$ is $S$-secure against existential forgeries under adaptive chosen message attacks ($S$-secure EF-CMA) if it has $S$ as a security profile in the following attack scenario:
\begin{enumerate}
\item $(\pubkey, \prikey) \gets \keygen$;
\item $(m,\sigma)\gets A^{\mathsf{S}(\prikey;)}(\pubkey)$;
\item The attack is successful iff $\mathsf{V}(\pubkey, m, \sigma)=1$
and $A$ never queries $\mathsf{S}(\prikey;m)$.
The success $\epsilon$ of $A$ is the probability that the attack is successful.
\end{enumerate}
\end{definition}

\subsection{One-Way Functions}

Let $f\colon X \rightarrow Y$ be any function from a range $X$ to a domain $Y$.

\begin{definition}[one-wayness]
A function $f$ is $S$-secure one-way if it has $S$ as a security profile in the following attack scenario:
\begin{enumerate}
\item $x\gets X$, i.e. $x$ is chosen uniformly at random from the domain $X$;
\item $x'\gets A(f(x))$;
\item The attack is successful if $f(x')=f(x)$,
and the success $\epsilon$ of $A$ is the probability that the attack is successful.
\end{enumerate}
\end{definition}

\subsection{Hash Functions}

\noindent A \emph{hash function family} is a pair $(\hfgen,\hfunc)$ where:
\begin{itemize}
\item $\hfgen$ is a probabilistic algorithm that chooses a parameter $\param$
\item $\hfunc$ is a deterministic algorithm such that for every value of $\param$, the function $H=\hfunc(\param; \cdot)$ is of type $\bits{\ast} \to \bits{k}$.
\end{itemize}

\begin{definition}[collision-resistance]
A hash function family $(\hfgen,\hfunc)$ is $S$-secure collision-resistant if it has $S$ as a security profile in the following attack scenario:
\begin{enumerate}
\item $\param \gets \hfgen$;
\item $(m,m')\gets A(\param)$;
\item The attack is successful iff $m\neq m'$ and $\hfunc(\param;m)=\hfunc(\param;m')$,
and the success $\epsilon$ of $A$ is the probability that the attack is successful
\end{enumerate}
\end{definition}

\noindent In the following, we assume that the sampling $\param \gets \hfgen$ has been done before any attack scenario, and we often say that the function $H=\hfunc(\param; \cdot)$ itself is collision-resistant regardless of the fact that no fixed function can formally be collision-resistant.

\begin{definition}[$(k,\ell)$-one-wayness]
A function $H\colon \{0,1\}^\ast\rightarrow\{0,1\}^k$
is $S$-secure $(k,\ell)-$\emph{one-way} if it has $S$ as a security profile in the following attack scenario:
\begin{enumerate}
\item $(h,a)\gets A_1$;
\item $x \gets \{0,1\}^\ell$;
\item $x'\gets A_2(a;H(h,x))$;
\item The attack is successful iff $h\in\{0,1\}^k$, $x'\in\{0,1\}^\ell$ and $H(h,x)=H(h,x')$.
The success $\epsilon$ of $A$ is the probability that the attack is successful
\end{enumerate}
\end{definition}

\noindent Equivalently, $H$ is $S$-secure $(k,\ell)$-one-way iff the function $f_h$ defined by $f_h(x)=H(h,x)$ is $S$-secure one-way for every $h\in\{0,1\}^k$.

\subsection{Commitment Schemes}

A \emph{commitment scheme} is a triple $(\setup, \commit, \open)$ of probabilistic algorithms such that:
\begin{itemize}
\item $\param\gets\setup$ is the setup algorithm that fixes the parameters of the scheme
\item $(c,d)\gets \commit(\param; m)$ computes commitment $c$ and
decommitment string $d$ of a message $m$
\item $m\gets \open(\param; c, d)$ opens the commitment
\end{itemize}
so that for every $m$, the following correctness identity holds:
\[
m=\open(\param; \commit(\param; m))\enspace.
\]
We denote by $\commitc(\param,m)$ the function that computes $(c,d)\gets \commit(\param; m)$ and returns $c$.
We will often omit the parameter $\param$ and use shorthand notations $\commit(m)$, $\commitc(m)$ and $\open(c,d)$ instead of $\commit(\param; m)$,
$\commitc(\param; m)$ and $\open(\param; c, d)$, respectively.
\medskip

\begin{definition}[trivial commitment scheme]
In the trivial commitment scheme $(\setup,\commit,\open)$ the functions are defined as follows:
\begin{itemize}
\item $\setup$ always returns $\bot$.
\item $\commit(m)=(m,\bot)$ is the identity function.
\item $\open (c,d) = c$ just returns the first argument.
\end{itemize}
\end{definition}

\noindent In terms of security, commitment schemes are required to be \emph{binding} and \emph{hiding}. Binding property means that once the commitment $c$ is fixed, it is not possible (or is very hard) to open it in two different ways. Hiding property means that the commitment $c$ must not contain efficiently extractable information about the committed message.

\subsubsection{Binding}

\begin{definition}[binding]
A commitment scheme $(\setup, \commit, \open)$ is $S$-secure computationally binding if it has $S$ as a security profile in the following attack scenario:
\begin{enumerate}
\item $\param\gets\setup$;
\item $c,d,d'\gets A(\param)$;
\item The attack is successful if $\open(\param; c, d)\neq\open(\param; c, d')$,
and the success $\epsilon$ of $A$ is the probability that the attack is successful.
\end{enumerate}
\end{definition}

\noindent This property is called \emph{computational binding} because it protects against adversaries with limited computational power. There exist commitment schemes that are \emph{perfectly binding}, which means that opening a commitment in two different ways is impossible by definition. For example, the trivial commitment is perfectly binding, however it is ``perfectly non-hiding'' because the commitment of $m$ is $m$ itself.

\subsubsection{Hiding}

\begin{definition}[perfect hiding]
A commitment scheme $(\setup, \commit, \open)$ is said to be perfectly hiding if for every $\param$ and for every two messages $m,m'$ the commitments $c\gets \commitc(\param; m)$ and $c'\gets \commitc(\param; m')$ have equal probability distributions as random variables (assuming that the two calls of $\commit$ use independent internal random strings).
\end{definition}

\begin{lemma}[output independence]\label{le:outputindependence}
If $(\setup, \commit, \open)$ is perfectly hiding commitment scheme, $m$ is chosen according to any probability distribution and $g$ is any deterministic function, then $m$ and $\commitc(g(m))$ are independent random variables.
\end{lemma}
\begin{proof}
Let $\omega \gets \Omega$ be the internal randomness sampling of $\commitc$. We denote by $\commitc_\omega$ the deterministic version of $\commitc$ where the internal random string $\omega$ is fixed. Let $\mathcal{M}$ denote the sampling space of $m$. We assume that the sampling $\mu\gets \mathcal{M}$ happens independently of $\omega \gets \Omega$ and hence, the total sampling space is a direct product space with sampling space $\mathcal{M}\times \Omega$ and $\prob[\mu,\omega]=\prob[\mu]\cdot \prob[\omega]$ for any values $\mu, \omega$.

Let $m=M(\mu,\omega)$ with $\mu\gets \mathcal{M}$ and $\omega\gets \Omega$, i.e. $M$ is the random variable corresponding to $m$. Let $C$ be the corresponding random variable of $c$, i.e. $c=C(\mu,\omega)=\commitc_\omega(g(M(\mu,\omega)))$. Note that $M(\mu,\omega)$ does not depend on $\omega$.

We have to show that $\prob[M=m,C=c] = \prob[M=m]\cdot \prob[C=c]$ in this probability space for any possible values $m,c$ of the message and the commitment, respectively.
\begin{eqnarray*}
\prob[M=m,C=c] &=& \sum_{\mu,\omega}\prob[\mu,\omega]\cdot [M(\mu,\omega)=m]\cdot [C(\mu,\omega)=c]\\
&=& \sum_{\mu,\omega}\prob[\mu]\cdot\prob[\omega]\cdot [M(\mu,\omega)=m]\cdot [C(\mu,\omega)=c]\\
&=& \sum_{\mu}\prob[\mu]\cdot[M(\mu,\omega)=m]\left(\sum_{\omega}\cdot\prob[\omega]\cdot [C(\mu,\omega)=c]\right)\\
&=& \sum_{\mu}\prob[\mu]\cdot[M(\mu,\omega)=m]\cdot
\prob[\commitc(g(M(\mu,\omega)))=c]\\
&=& \prob[\commit_\omega(g(M(\mu,\omega)))=c]\cdot \sum_{\mu}\prob[\mu]\cdot[g(M(\mu,\omega))=m]\\
&=& \prob[\commitc_\omega(g(M(\mu,\omega)))=c]\cdot \prob[M=m]
\end{eqnarray*}
because $p = \prob[\commitc_\omega(g(M(\mu,\omega)))=c]$ does not depend neither on $\mu$ due to the perfect hiding property, nor on $\omega$. Moreover:
\begin{eqnarray*}
p &=& \prob[\commitc(g(M(\mu,\omega)))=c] \cdot \overbrace{\sum_{\mu'} \prob[\mu']}^{=1}\\
&=& \sum_{\mu'} \prob[\mu']\cdot \prob[\commitc(g(M(\mu,\omega)))=c]\\
&=& \sum_{\mu'} \prob[\mu']\cdot \prob[\commitc(g(M(\mu',\omega)))=c]\\
&=& \sum_{\mu'} \prob[\mu']\cdot \sum_{\omega}\prob[\omega]\cdot [\commitc_\omega(g(M(\mu',\omega)))=c]\\
&=& \sum_{\mu',\omega} \prob[\mu',\omega]\cdot [\commitc_\omega(g(M(\mu',\omega)))=c] = \prob[C=c]
\end{eqnarray*}
that proves the claim.
\end{proof}

\subsection{Perfectly Hiding Commitments and One-Wayness}

Let $f$ be a one way function and $(\setup, \commit, \open)$ be a perfectly hiding commitment scheme. We will show, that $f$ remains hard to invert even if, in addition to the image $f(x)$, the adversary also know the commitment $\commitc(x)$. The following lemma shows that knowing $\commitc(x)$ does not help the adversary (much) in inverting a one-way function.

\begin{lemma}
If $f$ is $S_f$-secure one-way and $(\setup, \commit, \open)$ is a perfectly hiding commitment scheme, then $f$ is $S'_f$-secure in the following attack scenario:
\begin{enumerate}
\item $x\gets X$;
\item $x'\gets A(f(x),\commitc(x))$;
\item The attack is successful if $f(x')=f(x)$;
\end{enumerate}
where $S'_f(\epsilon) = S_f(\epsilon) - t_\mathsf{sm} - t_\mathsf{com}$, where $t_\mathsf{sm}$ and $t_\mathsf{com}$ are the running times of the samplings $\cdot\gets X$ and $\cdot\gets \commitc(\cdot)$, respectively.\footnote{The overhead function is $\tau(t)=t + t_\mathsf{sm} + t_\mathsf{com}$ and its inverse $\tau^{-1}(t) = t - t_\mathsf{sm} - t_\mathsf{com}$.}
\end{lemma}
\begin{proof}
Let $f$ be an $S$-secure one-way function and $A$ be a $t$-time adversary that with probability $\epsilon$ succeeds in the attack scenario.
Consider the following modified scenario with the same adversary:
\begin{enumerate}
\item $x\gets X$;
\item $x''\gets X$;
\item $x'\gets A(f(x),\commit(x''))$;
\item the attack is successful if $f(x')=f(x)$.
\end{enumerate}

\noindent From Lemma~\ref{le:outputindependence} it follows that in both input distributions $(f(x),\commit(x))$ and $(f(x),\commit(x''))$ the commitments are independent of $x$ and are equally distributed, and hence
the joint distributions of $(f(x),\commit(x))$ and $(f(x),\commit(x''))$ are equal. It follows that the success probability of $A$ in the second scenario is also equal to $\epsilon$. Let $A'(y)$ be the adversary that, given $y=f(x)$ as input proceeds as follows:
\begin{enumerate}
\item $x''\gets X$;
\item $c\gets \commit(x'')$;
\item return $A(y,c)$.
\end{enumerate}

\noindent The adversary $A'$ inverts $f$ with probability $\epsilon$ and has running time $t+t_\mathsf{sm} + t_\mathsf{com}$. Therefore, $t+t_\mathsf{sm} + t_\mathsf{com}\ge S_f(\epsilon)$ and hence $t\ge S_f(\epsilon)- t_\mathsf{sm} - t_\mathsf{com}$.
\end{proof}
\medskip

%\noindent This lemma can be straightforwardly generalized to the following lemma:
%\begin{lemma}
%A one-way function $f\colon X \rightarrow Y$ cannot be inverted much faster
%if the adversary, in addition to $f(x)$, knows the value of another (efficiently sampleable) random variable $c$ that is independent of $x\gets X$.
%\end{lemma}

\subsection{Pseudo-random Function Families}

\begin{definition}[PRF] An $S$-secure \emph{pseudo-random function family (PRF)} is a function $F\colon K\times X \rightarrow Y$ that has $S$ as a security profile in the following attack scenario with a distinguisher $D$:
\begin{enumerate}
\item $k\gets K$
\item $\Phi\gets Y^X$, i.e. $\Phi$ is a randomly chosen function of type $X\rightarrow Y$
\item $b_1\gets D^{F(k;\cdot)}$
\item $b_0\gets D^{\Phi(\cdot)}$
\item The success of $D$ is
$\epsilon=|\mathsf{Pr}[b_1=1]-\mathsf{Pr}[b_0=1]|$
\end{enumerate}
\end{definition}
The oracle $\Phi$ can be simulated by using the so-called \emph{lazy sampling} technique. The oracle stores a partial function (dictionary) $\phi$
that is initially nowhere defined (i.e. $\phi[x]=\bot$ for every $x\in X$) and every oracle call $\Phi(x)$ is handled as follows:
\begin{enumerate}
\item If $\phi[x]\neq \bot$ then return $\phi[x]$.
\item If $\phi[x]=\bot$ then:
\begin{enumerate}
\item Pick a random $y\gets Y$
\item Define $\phi[x]\gets y$
\item Return $y$
\end{enumerate}
\end{enumerate}



\section{Unicity Infrastructure}

Unicity infrastructure is about maintaining identifiable digital assets called \emph{tokens}. For example, tokens can represent units of digital currency.

\emph{Parties} can \emph{create (issue)} tokens, \emph{own} tokens, and \emph{transfer} tokens to each other, i.e. the ownership of tokens may change. In order to transfer a token, its owner makes a signed \emph{transaction} that redefines the ownership.

We assume that transferred tokens can be sent using any channels and their storage does not require dedicated hardware devices. At the same time, the infrastructure has to guarantee some properties of the tokens such as \emph{unique ownership}, i.e. the owner of a token should not be able to transfer the token to two different parties (i.e. \emph{double-spend} the token) and once a token has been transferred, neither the previous owner nor any third parties should be able to do anything with the token---transfer it or make it unusable for the next owner (i.e. \emph{block} the token).

As nothing prevents copying of digital information, some additional components are needed in the infrastructure to guarantee the desired properties of tokens. For this, the Unicity infrastructure includes the \emph{Unicity Service}---an online functionality that all parties can communicate with.


In this section, we assume that $(\keygen, \sig, \sigver)$ is a signature scheme and $H$ is a hash function.

\subsection{Unicity Service}

We first model the Unicity Service as an ideal functionality, and later discuss how to implement such a service in a secure and efficient way.

The \emph{Unicity Service} $\unisrv$ is modeled as a state machine with state $R$, which is a key-value store (dictionary), where both keys and values are of type $\bits{|k|}$. Initially, $R = \emptyset$. We will write $R[k] = \bot$ if there are no pairs $(k, v)$ stored in $R$.

Every input request $Q$ is a tuple $(\pubkey, \sthash, \txhash, \sigma)$, where:
\begin{itemize}
\item $\pubkey$ of type $\bits{p}$ is a public key: the public key of the current owner of a token, i.e. the owner before the transaction with the hash $\txhash$ is executed;
\item $\sthash$ of type $\bits{k}$ is a state hash: the hash of the state of the token before the transaction is executed;
\item $\txhash$ of type $\bits{k}$ is a transaction data hash (defined later);
\item $\sigma$ of type $\bits{s}$ is a digital signature of the transaction.
\end{itemize}

\noindent The request $Q=(\pubkey,\sthash,\txhash,\sigma)$ is processed by $\unisrv$ with the state $R$ as follows:
\begin{enumerate}
\item If $R[H(\pubkey, \sthash)] = \bot$ and $\sigver(\pubkey, H(\sthash, \txhash), \sigma) = 1$ then
\[
R \gets R \cup \{(H(\pubkey, \sthash), \txhash)\} \enspace,
\]
i.e. the new value of $R$ is defined by setting $R[H(\pubkey, \sthash)] \gets \txhash$ and leaving the rest of the contents of $R$ unchanged.
\item A proof $\pinc$ of the statement $R[H(\pubkey, \sthash)] = v$ (inclusion proof) is returned.
\end{enumerate}

\noindent It is easy to see that if $R_0 = \emptyset$ is the initial state, $Q_1, Q_2, \ldots, Q_n$ is any sequence of queries, and $R_i$ is the state after the request $Q_i$ then:
\begin{itemize}
\item $R_0 \subseteq R_1 \subseteq \ldots \subseteq R_n$, i.e. the elements are never removed.
\item The state $R_n$ is a \emph{partial function}, i.e.
$\{(k, v), (k, v')\} \subseteq R$ implies $v = v'$.
\end{itemize}

We say that a key $k$ is \emph{blocked} if $R[k] \neq \bot$.

\subsection{Verification Function}

We assume that the inclusion proofs $\pinc$ can be verified by any party using a verification function $\univer$ so that:
\begin{itemize}
\item If $\univer(k, v; \pinc) = 1$ then $R[k] = v$ in the current state $R$ of $\unisrv$. Hence, as $R$ is a partial function, for every $k, v, v', \pinc, \pinc'$, the following implication holds:
\begin{equation}\label{eq:eqtx}
\univer(k, v; \pinc) = \univer(k, v'; \pinc') = 1 \quad \Rightarrow \quad v =v' \enspace.
\end{equation}
\item If $R[H(\pubkey, \sthash)] = \txhash$ after a request $\pinc \gets \unisrv(\pubkey, \sthash, \txhash, \sigma)$ to the Unicity Service, then $\univer(H(\pubkey, \sthash), \txhash, \pinc) = 1$.
\end{itemize}

\subsection{Transactions with a Token}

Every token has a state hash $\sthash$ and an owner $A$ with a public key $\pubkey$. We will call the pair $(\pubkey, \sthash)$ a \emph{state} of the token.
Every (unsigned) transaction with the token is a pair
$T = (\sthash, D)$, where:
\begin{enumerate}
\item $\sthash$ is the state hash before executing the transaction,
\item $D$ contains the following fields:
\begin{itemize}
\item $\pubkey'$: the public key of the next owner,
\item $x$: a uniformly chosen random string $x\gets\{0,1\}^\ell$,
\item $\auxd$: other data of the transaction.
\end{itemize}
\end{enumerate}

\noindent\textbf{Certifying a transaction} $T = (\sthash, D)$ involves the following steps:
\begin{enumerate}
\item $(\txhash,d) \gets \commit(H(D))$ is computed using a perfectly hiding commitment scheme $(\setup,\commit,\open)$.
The commitment $\txhash$ is called the \emph{transaction data hash}.
\item The hash value $h_T = H(\sthash, \txhash)$ is computed.
\item A digital signature $\sigma \gets \sig(\prikey, h_T)$ is created with the private counterpart $\prikey$ of $\pubkey$, i.e. $\mathsf{V}(\pubkey, h_T, \sigma) = 1$.
%\item A \emph{signed transaction} $(T,\sigma,d)$ is formed.
\item The query $Q = (\pubkey,\sthash,\txhash,\sigma)$ is created.
\item $\unisrv$ is called to obtain $\pi\gets \unisrv(Q)$.
\item The certified transaction $(T,\sigma,\txhash,d,\pi)$ is formed.
\end{enumerate}

\noindent\textbf{Verifying a certified transaction} A certified transaction $(T,\sigma,\txhash,d,\pi)$ is verified in the state $(\pubkey,h)$ by the following algorithm:\medskip

\noindent $\certver(T,\sigma,\txhash,d,\pi;\pubkey,h)$:
If at least one of the following checks fail, return 0, otherwise return 1:
\begin{enumerate}
\item $T.\sthash=h$;
\item $\open(\txhash,d)=H(T.D)$;
\item $\sigver(\pubkey, H(\sthash,\txhash),\sigma)=1$;
\item $\univer(H(\pubkey,T.\sthash),\txhash,\pi)=1$.
\end{enumerate}

\begin{definition}[certification in a state]\label{de:certstate}
A tuple $(T,\sigma,\txhash,d,\pi)$ is said to be \emph{certified in state} $(\pubkey,h)$ iff $\certver(T,\sigma,\txhash,d,\pi;\pubkey,h)=1$.
\end{definition}


\subsection{Mint Transaction}

Mint transaction is the first transaction with every token. Mint transaction assigns a unique \emph{Token Identifier} $\mathsf{id}$ and some more application-specific data fields, like a \emph{Mint Justification}, packed into the auxiliary data $\auxd$.

A certified mint transaction is $(T_0, \sigma_0, \pi_0)$, where $T_0 = (\sthash, D_\mathsf{mint})$ and $D_\mathsf{mint}$ contains the following fields:
\begin{itemize}
    \item $\pubkey'$: the public key of the first owner;
    \item $\mathsf{id}$: the token identifier;
% \item $x$: a uniformly chosen random string $x\gets\{0,1\}^\ell$;
    \item $\auxd$: other data of the transaction.
\end{itemize}

\noindent A Mint transaction is signed by a fixed, public keypair $(\pubkey_\mathsf{mint}, \prikey_\mathsf{mint})$. This ensures the uniqueness of every token identifier. $\mathsf{MINT\_SUFFIX}$ is a fixed domain separator.\medskip

\noindent\textbf{Certifying a mint transaction} $T = (\sthash, D_\mathsf{mint})$ involves the following steps:
\begin{enumerate}
    \item $\sthash = H(\mathsf{id}, \mathsf{MINT\_SUFFIX})$ is computed.
	\item $\txhash = H(D_\mathsf{mint})$ is computed.
	\item $h_T = H(\sthash, \txhash)$ is computed.
	\item A digital signature $\sigma \gets \sig(\prikey_\mathsf{mint}, h_T)$ is created with the (publicly known, fixed) private key $\prikey_\mathsf{mint}$.
	\item The request $Q = (\pubkey_\mathsf{mint},\sthash,\txhash,\sigma)$ is created.
	\item $\unisrv$ is called to obtain $\pi\gets \unisrv(Q)$.
	\item The certified mint transaction $(T,\sigma,\pi)$ is formed.
\end{enumerate}

\noindent\textbf{Verifying a certified mint transaction} $(T,\sigma,\pi)$ (with $T=(\sthash, D_\mathsf{mint})$) in state $(\pubkey,h)$ involves the following checks:
\begin{enumerate}
	\item $\sthash=h$;
	\item $\txhash = H(D_\mathsf{mint})$;
	\item $\sigver(\pubkey_\mathsf{mint}, H(\sthash,\txhash),\sigma)=1$;
	\item $\univer(H(\pubkey_\mathsf{mint},\sthash),\txhash,\pi)=1$.
\end{enumerate}

\noindent Application-specific checks (e.g., validation of the mint authorization based on the enclosed mint justification) follow.

\subsection{Token Ledger}

A \emph{token ledger} is a sequence
\[
(T_0, \sigma_0, \pi_0; h^1_\mathsf{st}), (T_1, \sigma_1,\txhash^1,d_1,\pi_1; h^2_\mathsf{st}), \ldots, (T_n, \sigma_n, \txhash^n, d_n,\pi_n; h^{n+1}_\mathsf{st})
\]
where $(T_0, \sigma_0, \pi_0)$ is a certified mint transaction and for every index $i=1,\ldots, n$:
\begin{enumerate}
\item $(T_{i}, \sigma_{i}, \txhash^i,d_i, \pi_{i})$ is a certified transaction in the state $(T_{i-1}.D.\pubkey', h^{i-1}_\mathsf{st})$;
\item $h^{i}_\mathsf{st}=H(h^{i-1}_\mathsf{st},x_{i-1})$ where $x_{i-1} =T_{i-1}.D.x$.
\end{enumerate}

\section{Security}
Consider a token with the state $S = (\pubkey, \sthash)$. The transfer protocol ensures the following properties:
\begin{itemize}
\item \emph{No blocking}:
Only the owner of the private key of $\pubkey$ can block the state $S = (\pubkey, \sthash)$ if it was not blocked before.
\item \emph{No double-spending}:
Only one certified transaction can be created in the state $S$.
\end{itemize}

\noindent In this section, we present security proofs for both the no blocking and the no double-spending properties. Security against blocking does not depend on the choice of the commitment scheme and security against double spending assumes computational binding of the commitment scheme.

Therefore, both proofs are also valid if the commitment scheme is trivial (i.e. $\txhash = H(D)=H(\pubkey',x,\auxd)$) because the trivial commitment scheme is perfectly (and hence also computationally) binding. Later when we prove the privacy properties, we have to assume that the commitment scheme is perfectly hiding.



\subsection{Security against Blocking}

A blocking adversary $A$ uses two oracles:
\begin{enumerate}
\item $\mathsf{US}$: the Unicity Service,
\item $\mathsf{TS}(\prikey,\cdot)$: the transaction signer that, given as input a transaction $(h,D)$ returns $(\sigma, \txhash, d)$, where
$(\txhash, d)\gets \commit(H(D))$ and
$\sigma \gets \mathsf{S}(\prikey,H(h,\txhash))$.
\end{enumerate}

\noindent\textbf{Blocking scenario} involves the following steps:
\begin{enumerate}
\item $(\pubkey,\prikey)\gets \mathsf{G}$, i.e. a keypair is generated;
\item $h_\mathsf{st}\gets A^{\mathsf{US},\mathsf{TS}(\prikey,\cdot)}(\pubkey)$, i.e. $A$ outputs a hash value;
\item $A$ is successful if
$R[H(\pubkey,h_\mathsf{st})]\neq\bot$ after the scenario and no queries of the form $(\sigma,\txhash,d)\gets\mathsf{TS}(\prikey;h_\mathsf{st},D))$ were made.
The success $\epsilon$ of $A$ is the probability that the attack is successful
\end{enumerate}

\noindent Note that if such a query was made, then the request $Q=(\pubkey,\sthash, \txhash,\sigma)$ to $\mathsf{US}$ will trivially ensure $R[H(\pubkey,h_\mathsf{st})]\neq\bot$, and hence this is excluded by the security condition. \medskip

\begin{definition}[blocking security]
The Unicity Service is said to be $S$-secure against blocking if it has $S$ as a security profile in the blocking scenario.
\end{definition}

\noindent\textbf{Anaysis}: The adversary $A$ can be successful in the following cases:
\begin{itemize}
\item[a)] A request $Q=(\pubkey', h'_\mathsf{st}, h_\mathsf{tx}, \sigma)$ with $(\pubkey',h'_\mathsf{st})\neq (\pubkey,h_\mathsf{st})$ to $\mathsf{US}$ enforces $R[H(\pubkey, h_\mathsf{st})]\neq\bot$, which means that  $H(\pubkey,h_\mathsf{st})=H(\pubkey', h'_\mathsf{st})$ and hence, a collision for $H$ was found.
\item[b)] A request $Q=(\pubkey, h_\mathsf{st}, h_\mathsf{tx}, \sigma)$ to $\mathsf{US}$ enforces $R[H(\pubkey, h_\mathsf{st})]\neq\bot$, which implies $\mathsf{V}(\pubkey, H(h_\mathsf{st},h_\mathsf{tx}), \sigma)=1$ from the description of $\mathsf{US}$. Then we have two possibilities:
\begin{itemize}
\item[b1)] A request $(\sigma',\txhash',d)\gets\mathsf{TS}(\prikey;\sthash',D)$ with $\sthash'\neq h_\mathsf{st}$ was made such that
$H(\sthash',\txhash')=H(\sthash,\txhash)$, which means that a collision for $H$ was found.
\item[b2)] If no requests $(\sigma',\txhash',d)\gets\mathsf{TS}(\prikey;\sthash',D)$ were made with $H(\sthash',\txhash')=H(\sthash,\txhash)$ then this means that $A$ was able to create the signature $\sigma$ without ``help'' from the $\mathsf{TS}(\prikey;\cdot)$ oracle, and hence $A$ was able to create an existential forgery against the signature scheme.
\end{itemize}
\end{itemize}

\begin{theorem}
If the signature scheme is $S$-secure EF-CMA and the hash function is $S$-secure collision-resistant, then the Unicity service is
$S_\mathsf{block}$-secure against blocking, where $S_\mathsf{block}(\epsilon) =
\frac{S(\epsilon/2)}{\max\{t_\mathsf{ver}, t_\mathsf{sig}\}+1} - \frac{t_\mathsf{gen}}{\max\{t_\mathsf{ver}, t_\mathsf{sig}\}+1}$
and
$t_\mathsf{gen}$, $t_\mathsf{sig}$, $t_\mathsf{ver}$ are the
key generation time, signing time, and signature verification time, respectively.
\end{theorem}
\begin{proof}
Let $A$ be a $t$-time blocking adversary that succeeds with probability $\epsilon$. We construct a collision-finder $A_\mathsf{coll}$ and an
existential forger $A_\mathsf{ex}$ as follows:
\begin{itemize}
\item $A_\mathsf{coll}$ proceeds as follows:
 \begin{enumerate}
   \item $(\pubkey,\prikey)\gets \mathsf{G}$.
   \item Simulates $h_\mathsf{st}\gets A^{\mathsf{US},\mathsf{TS}(\prikey;\cdot)}(\pubkey)$ and records all the oracle queries.
   \item If $A^{\mathsf{US},\mathsf{TS}(\prikey;\cdot)}(\pubkey)$ was successful and either the case a) or b1) occurs, $A_\mathsf{coll}$ outputs the collision that is guaranteed in this case.
 \end{enumerate}
The oracles are simulated as follows:
 \begin{itemize}
   \item $\mathsf{US}$-queries: $A_\mathsf{coll}$ maintains its own version of $R$.
   \item $\mathsf{TS}(\prikey;\cdot)$-queries: $A_\mathsf{coll}$ uses the private key $\prikey$.
\end{itemize}
The computational time overhead function for the construction of $A_\mathsf{coll}$ is $\tau_\mathsf{coll}(t) = (\max\{t_\mathsf{ver}, t_\mathsf{sig}\}+1)\cdot t + t_\mathsf{gen}$, where
$t_\mathsf{ver}$ is the signature verification time (for $\unisrv$-queries),
$t_\mathsf{sig}$ is the signature creation time (for $\mathsf{TS}(\prikey;\cdot)$-queries), and $t_\mathsf{gen}$ is the key generation time.

\item $A_\mathsf{ex}^{\mathsf{S(\prikey;\cdot)}}(\pubkey)$ proceeds as follows:
 \begin{enumerate}
  \item Simulates $h_\mathsf{st}\gets A^{\mathsf{US},\mathsf{TS}(\prikey;\cdot)}(\pubkey)$ and records all the oracle queries.
  \item If $A^{\mathsf{US},\mathsf{TS}(\prikey;\cdot)}(\pubkey)$ was successful and b2) occurs and $Q=(\pubkey, h_\mathsf{st}, h_\mathsf{tx}, \sigma)$ was the request that enforces $R[H(\pubkey, h_\mathsf{st})]\neq\bot$ then:
  \begin{enumerate}
    \item[3.] $m\gets H(h_\mathsf{st}, h_\mathsf{tx})$.
    \item[4.] Output $(m,\sigma)$.
  \end{enumerate}
 \end{enumerate}
The oracles are simulated as follows:
 \begin{itemize}
  \item $\mathsf{US}$-queries are simulated so that $A_\mathsf{coll}$ maintains its own version of $R$.
  \item $\mathsf{TS}(\prikey;\cdot)$-queries are simulated by using calls to $\mathsf{S}(\prikey;\cdot)$.
 \end{itemize}
 As the request $Q$ was accepted by $\unisrv$, we have $\sigver(\pubkey,m,\sigma)=1$. Note that in the case b2) the request $\mathsf{S}(\prikey; m)$ was never made and hence, $A_\mathsf{ex}^{\mathsf{S(\prikey;\cdot)}}(\pubkey)$ is successful as an existential forger in the EF-CMA scenario. The computational time overhead function for the construction of $A_\mathsf{ex}$ is $\tau_\mathsf{ex}(t) = (t_\mathsf{ver}+1)\cdot t + t_\mathsf{hash}$, where
$t_\mathsf{ver}$ is the signature verification time (for $\unisrv$ queries) and
$t_\mathsf{hash}$ is the hash computation time (for output).
\end{itemize}
If $A$ succeeds, then either $A_\mathsf{coll}$ or $A_\mathsf{ex}$ succeds and hence $\epsilon \le \epsilon_\mathsf{coll} + \epsilon_\mathsf{ex}$.
Assuming that $t_\mathsf{hash}\le t_\mathsf{gen}$, the inequality
$\tau_\mathsf{ex}(t)\le \tau_\mathsf{coll}(t)$ holds and hence by equation (\ref{eq:losebound})
\[
S_\mathsf{block}(\epsilon) = \tau^{-1}_\mathsf{coll}(S(\epsilon/2)) =
\frac{S(\epsilon/2)}{\max\{t_\mathsf{ver}, t_\mathsf{sig}\}+1} - \frac{t_\mathsf{gen}}{\max\{t_\mathsf{ver}, t_\mathsf{sig}\}+1}
\]
is a security profile of the Unicity Service against blocking.
\end{proof}

\subsection{Security against Double-Spending}

A double-spending adversary uses $\unisrv$ as an oracle. \medskip

\noindent\textbf{Double-spending scenario} involves the following steps:
\begin{enumerate}
\item $(T,\sigma,\txhash,d,\pinc),(T',\sigma',\txhash',d',\pinc'),(\pubkey,h)\gets A^\unisrv$.
\item The attack is successful iff $T\neq T'$ and
\begin{equation}\label{eq:dscond}
\certver(T,\sigma,\txhash,d,\pinc;\pubkey,h)=\certver(T',\sigma',\txhash',d',\pinc';\pubkey,h)=1 \enspace.
\end{equation}
\end{enumerate}

\begin{definition}[Double-spending security]
The Unicity Service is said to be $S$-secure against double-spending if it has $S$ as a security profile in the double-spending scenario.
\end{definition}

\noindent\textbf{Anaysis}: If the adversary is successful, then
from (\ref{eq:dscond}) and the definition of $\certver$ it follows that
$T.\sthash = T'.\sthash=h$ and:
\begin{eqnarray*}
\univer(H(\pubkey, h), \txhash; \pinc) = \univer(H(\pubkey, h), \txhash'; \pinc') = 1\enspace,
\end{eqnarray*}
which implies $\txhash=\txhash'$ by equation~(\ref{eq:eqtx}).
From Def.~\ref{de:certstate} it also follows that
$\open(\txhash,d)=H(T.D)$ and $\open(\txhash,d')=\open(\txhash',d')=H(T'.D)$.
From $(h,T.D)=(T.\sthash,T.D)=T\neq T'=(T'.\sthash,T'.D)=(h,T'.D)$ it follows that $T.D\neq T'.D$. Hence, we have two cases:
\begin{itemize}
\item[a)] $H(T.D)=H(T'.D)$, which
means that a collision has been found for $H$.
\item[b)] $H(T.D)\neq H(T'.D)$, which implies $\open(\txhash,d)=H(T.D)\neq H(T'.D)=\open(\txhash,d')$ and hence, the commitment $\txhash$ has been opened in two different ways.
\end{itemize}

\begin{theorem}
If $H$ is $S$-secure collision-resistant and the commitment scheme is $S$-secure computationally binding, then the Unicity service is $S_\mathsf{double}$-secure against double-spending, where
$S_\mathsf{double}(\epsilon) = \frac{S(\epsilon/2)}{t_\mathsf{ver}+1}$
and $t_\mathsf{ver}$ is the signature verification time.
\end{theorem}
\begin{proof}
Let $A$ be a $t$-time double-spending adversary that succeeds with probability $\epsilon$. We construct a collision-finder $A_\mathsf{coll}$ for the hash function and a double-opening adversary $A_\mathsf{com}$ for the commitment scheme as follows:
\begin{itemize}
\item $A_\mathsf{coll}$ proceeds as follows:
\begin{enumerate}
\item Simulate $(T,\sigma,\txhash,d,\pinc),(T',\sigma',\txhash',d',\pinc'),(\pubkey,h)\gets A^\unisrv$ by maintaining its own version of $\unisrv$.
\item Output the pair $(T.D,T'.D)$.
\end{enumerate}
The computational overhead function of $A_\mathsf{coll}$ is $\tau_\mathsf{coll}(t) = (t_\mathsf{ver}+1) \cdot t$, because simulating a $\unisrv$ query requires one signature verification and the number of calls is limited by the running time $t$ of $A$.
\item $A_\mathsf{com}$ proceeds as follows:
\begin{enumerate}
\item Simulate $(T,\sigma,\txhash,d,\pinc),(T',\sigma',\txhash',d',\pinc'),(\pubkey,h)\gets A^\unisrv$ by maintaining its own version of $\unisrv$.
\item Output the triple $(\txhash,d,d')$.
\end{enumerate}
The computational overhead function of $A_\mathsf{com}$ is the same as
that of $A_\mathsf{coll}$, i.e. $\tau_\mathsf{com}(t)= \tau_\mathsf{coll}(t)=(t_\mathsf{ver}+1) \cdot t$.
\end{itemize}
 If $A$ succeeds, then in case a) the collision finder $A_\mathsf{coll}$ succeeds, and in case b) the double-opener $A_\mathsf{com}$ succeeds. Hence, $\epsilon \le \epsilon_\mathsf{coll} + \epsilon_\mathsf{com}$, where $\epsilon_\mathsf{coll}$ is the success probability of $A_\mathsf{coll}$ and
$\epsilon_\mathsf{com}$ is the success probability of $A_\mathsf{com}$.
Therefore, by equation (\ref{eq:losebound}), the function $S_\mathsf{double}$ defined by
\[
S_\mathsf{double}(\epsilon) = \tau^{-1}_\mathsf{coll}(S(\epsilon/2)) =
\frac{S(\epsilon/2)}{t_\mathsf{ver}+1}
\]
is a security profile of the Unicity service against double-spending.
\end{proof}

\subsection{Insecure Modifications of the Unicity Service}

\subsubsection{State Hash not Signed}

Consider the following modification of $\mathsf{US}$ that given a request $Q=(\pubkey, h_\mathsf{st}, h_T, \sigma)$ proceeds as follows:
\begin{enumerate}
\item If $R[H(\pubkey, h_\mathsf{st})]=\bot$ and $\sigver(\pubkey, h_T, \sigma)=1$ then $R[H(\pubkey, h_\mathsf{st})]\gets h_T$.
\item Return a proof $\pi$ of the statement $R[H(\pubkey, h_\mathsf{st})]=h_T$.
\end{enumerate}

\noindent Assume that a user $A$ owns a token in state $(\pubkey,\sthash)$.
A malicious user that knows any pair  $(h,\sigma)$ such that $\sigver(\pubkey,h,\sigma)=1$
can now lock $A$-s token by sending malicious request $Q=(\pubkey,\sthash, h, \sigma)$ to $\mathsf{US}$.
Other users may indeed know such pairs if they have received tokens from $A$ (and hence, having seen transactions $(T,\sigma)$ signed by $A$).
Hence, such a $\unisrv$ is insecure against blocking.

\subsubsection{$R$ as a Set}

Consider the following modification of $\mathsf{US}$ where $R$ is just a set and a request $Q=(\pubkey, \sthash, \txhash, \sigma)$ is processed as follows:
\begin{enumerate}
\item If $H(\pubkey, \sthash)\not\in R$ and $\mathsf{V}(\pubkey, H(\sthash, \txhash), \sigma)=1$ then $R\gets R \cup \{H(\pubkey, \sthash)\}$.
\item Return a proof $\pinc$ of the statement $H(\pubkey, \sthash)\in R$.
\end{enumerate}

\noindent The verification function $\univer$ just ignores the second argument, i.e.  $\univer(k,v,\pi)=1$ holds iff $k\in R$ in the current state of $\unisrv$. \medskip

\noindent A user $A$ who owns a token in state $(\pubkey,\sthash)$ (such that $H(\pubkey,\sthash)\not\in R$) can now proceed as follows:
\begin{enumerate}
\item $A$ creates two signed transactions $(T_1,\sigma_1)$ and $(T_2,\sigma_2)$ with
$T_1=(\sthash,D_1)$ and $T_2=(\sthash,D_2)$ with $T_1.D.\pubkey'\neq T_2.D.\pubkey'$, i.e. $T_1$ and $T_2$ transfer the same token to two different public keys.
\item Let $(\txhash^1,d_1)\gets \commit(H(D_1))$ and $(\txhash^2,d_2)\gets \commit(H(D_2))$.
\item $A$ calls $\pinc\gets\unisrv(Q)$, where $Q=(\pubkey,\sthash,\txhash^1,\sigma_1)$ and $\pinc$ is a proof of the statement $H(\pubkey,\sthash)\in R$. After that, $H(\pubkey,\sthash)\in R$ holds.
\item Also, both $(T_1,\sigma_1,\txhash^1,d_1, \pinc)$ and $(T_2,\sigma_2,\txhash^2,d_2, \pinc)$ are certified transactions in $(\pubkey,\sthash)$ because, as $H(\pubkey,\sthash)\in R$:
\[
\univer(H(\pubkey,\sthash),\txhash^1,\pinc)=
\univer(H(\pubkey,\sthash),\txhash^2,\pinc)=1\enspace.
\]
\end{enumerate}

\noindent Therefore, such a $\unisrv$ is insecure against double-spending.

\section{Service Side Privacy}

Unicity service $\unisrv$ obtains information about the transactions $T=(\sthash,D)$ with tokens via the queries $Q=(\pubkey, \sthash, \txhash,\sigma)$. We want to ensure that $\unisrv$ does not learn too much about the contents and context of transactions, for example, which transaction belongs to which token.

Assume that a token is currently in the state $(\pubkey,\sthash)$ and the next transaction with the token is $T=(\sthash, D)$, where $D=(\pubkey',x,\mathsf{aux})$. To certify $T$, the query
$Q=(\pubkey,\sthash,\txhash,\sigma)$ is sent to $\unisrv$ where $\txhash=\commitc(H(D))$ and $\sigma = \sig(\prikey; H(\sthash,\txhash))$.
Assume that $\unisrv$ stores the transaction $Q$.
In the future, the next transaction $T'=(\sthash',D')$ will be executed with the same token and the query
$Q'=(\pubkey',\sthash',\txhash',\sigma')$ with $\sthash'=H(\sthash,x)$ will be received by $\unisrv$.

We do not want $\unisrv$ to be able to associate $Q$ and $Q'$ as two consecutive transactions with the same token. Such association is possible if $\unisrv$ somehow obtains the random $x$ included into the transaction $T$, because $\unisrv$ can then check that $H(\sthash,x)=\sthash'=f_{\sthash}(x)$. There are several ways how to find $x$:
\begin{itemize}
\item Invert the function $f_{\sthash}(\cdot)=H(\sthash,\cdot)$, i.e. find $x'$ such that $f_{\sthash}(x')=\sthash'$ and hope that $x'=x$. To prevent that, we may assume that the hash function $H$ is $(k,\ell)$-one-way.
\item Find $x$ based on the commitment $\txhash=\commitc(D)$. To prevent that, we may assume that the commitment scheme is computationally hiding.
\item Combine both techniques, i.e. invert $f_{\sthash}(x)$ with additional information about $x$ obtained from $\txhash$. To prevent that, we assume that the commitment scheme in use is \emph{perfectly hiding}. We will give a proof later in this section under some reasonable assumptions.
\end{itemize}

\noindent Note that if $\ell$ is large, then $H(\sthash,x)$ with $x\gets \{0,1\}^\ell$ may give very little information about the previous state hash $\sthash$.
For example, an extreme case is that if $\ell=k$ and the function $H(h,\cdot)\colon \{0,1\}^k\rightarrow \{0,1\}^k$ happens to be one-to-one for every $h$ (which most likely never happens for practical hash functions) then in fact $H(\sthash,x)$ gives no information on $\sthash$  because the equation $H(h,x)=\sthash'$ can be (uniquely) solved for every state hash $h$ that $\unisrv$ has stored or memorized. In practice, there is no need to choose very large $\ell$ as practical security is possible if $\ell$ is much smaller than $k$.

\subsection{Security against Association}

Association adversary $A=(A_1,A_2)$ is two-stage. \medskip

\noindent\textbf{Association scenario} involves the following steps:
\begin{enumerate}
\item $(\sthash, \pubkey', \auxd, a)\gets A_1$.
\item $x\gets \{0,1\}^\ell$.
\item $\sthash'\gets H(\sthash,x)$.
\item $\txhash\gets\commitc(H(\pubkey',x,\auxd)))$.
\item $x'\gets A_2(a; \sthash',\txhash)$.
\item The attack is successful iff $\sthash\in\{0,1\}^k$, $x'\in\{0,1\}^\ell$, and $H(\sthash,x')=\sthash'$. The success $\epsilon$ of $A$ is the probability that the attack is successful
\end{enumerate}

\begin{definition}[association security]
The Unicity Service is said to be $S$-secure against association if it has $S$ as a security profile in the association scenario.
\end{definition}


\begin{theorem}
If the hash function is $S$-secure $(k,\ell)$-one-way and the commitment scheme is perfectly hiding, then the Unicity Service is $S_\mathsf{assoc}$-secure against association, where $S_\mathsf{assoc}(\epsilon)= S(\epsilon) - t_\mathsf{sm} - t_\mathsf{hash} - t_\mathsf{com}$, where
$t_\mathsf{sm}$, $t_\mathsf{hash}$, $t_\mathsf{com}$ are the random sampling time, hashing time, and the commitment computation time, respectively.
\end{theorem}
\begin{proof}
Let $A=(A_1,A_2)$ be a $t$-time adversary that succeeds in the association scenario with probability $\epsilon$. Consider the following modified attack scenario:
\begin{enumerate}
\item $(\sthash, \pubkey', \auxd, a)\gets A_1$.
\item $x\gets \{0,1\}^\ell$.
\item $\sthash'\gets H(\sthash,x)$.
\item $x''\gets \{0,1\}^\ell$.
\item $\txhash'\gets\commitc(H(\pubkey',x'',\auxd)))$.
\item $x'\gets A_2(a; \sthash',\txhash')$.
\item The attack is successful iff $\sthash\in\{0,1\}^k$, $x'\in\{0,1\}^\ell$, and $H(\sthash,x')=\sthash'$.
\end{enumerate}
%For any fixed value of $L=(\sthash, \pubkey', \auxd, a)$, due to the perfect hiding, the probability distributions of $\txhash$ and $\txhash'$ are equal and due to Lemma~\ref{le:outputindependence} (by taking $g(x)=H(\pubkey',x,\auxd))$), the random variables $\txhash$ and $\txhash'$ are both independent of $x$. This means that the arguments $(\sthash',\txhash)$ and $(\sthash',\txhash')$ of $A(a;\cdot)$ are equal
%in both scenarios, and hence $A$ succeeds in the modified scenario with probability $\epsilon$. We construct an adversary $A'=(A'_1,A'_2)$ as follows:

\noindent For any fixed value of $L=(\sthash, \pubkey', \auxd, a)$, due to perfect hiding, the commitments $\txhash=\commitc(H(\pubkey',x,\auxd))$ and $\txhash'=\commitc(H(\pubkey',x'',\auxd))$ have equal probability distributions. Moreover, by Lemma~\ref{le:outputindependence} (with $g(x)=H(\pubkey',x,\auxd)$), the random variables $x$ and $\txhash=\commitc(H(\pubkey',x,\auxd))$ are independent.

Since $x''$ and $x$ are independent, the commitment $\txhash'=\commitc(H(\pubkey',x'',\auxd))$ is independent of both $x$ and $\sthash'=H(\sthash,x)$. Therefore, the joint distributions of $(\sthash',\txhash)$ and $(\sthash',\txhash')$ are equal, and hence $A$ succeeds in the modified scenario with probability $\epsilon$. We construct an adversary $A'=(A'_1,A'_2)$ as follows:
\begin{itemize}
\item $A'_1$ proceeds as follows:
\begin{enumerate}
\item $(\sthash, \pubkey', \auxd, a)\gets A_1$;
\item return $(\sthash, a')$, where $a'=(\pubkey', \auxd, a)$.
\end{enumerate}
\item $A'_2(a';y)$ with $a'=(\pubkey', \auxd, a)$ proceeds as follows:
\begin{enumerate}
\item $x''\gets \{0,1\}^\ell$;
\item $\txhash'\gets\commitc(H(\pubkey',x'',\auxd)))$;
\item $x'\gets A_2(a; y,\txhash')$;
\item return $x'$.
\end{enumerate}
\end{itemize}

\noindent The computational time overhead function of $A'$ is $\tau(t) = t + t_\mathsf{sm} + t_\mathsf{hash} + t_\mathsf{com}$ and hence, by equation (\ref{eq:losebound}), the function $S_\mathsf{assoc}$ defined by
\[
S_\mathsf{assoc}(\epsilon) = \tau^{-1}(S(\epsilon)) = S(\epsilon) - t_\mathsf{sm} - t_\mathsf{hash} - t_\mathsf{com}
\]
is a security profile of the Unicity service against association.
\end{proof}

\subsection{Discussion}

The security proofs against blocking and double spending are also valid in case when the commitment scheme is omitted from the construction and the transaction data hash is computed by $\txhash = H(\pubkey',x,\auxd)$.
At the same time, there seem to be no obvious ways of proving that such a simplified scheme is secure against association.

Still, it may be a plausible practical assumption that given $\sthash$ and the next state hash $\sthash'=H(\sthash,x)$ and $\txhash = H(\pubkey',x,\auxd)$ it is infeasible to find $x'$ so that $H(\sthash,x')=\sthash'$. At least for example, if $H$ is \textsf{SHA-256}, there seem to be no obvious ways how to do it if $x$ has sufficiently many random bits.

\section{User Side Privacy}


In the previous sections, there is an assumption that the recipient generates a fresh keypair for every transaction. This may be impractical in some applications, especially where the recipient's secure storage is limited. We present two solutions that allow for the generation of unlinkable public keys while maintaining only a single persistent private key.

As a requirement, we avoid the persistent state on the client side that must be retained between transactions.

\subsection{A General Solution using Pseudo-Random Functions}

In this subsection, we define \emph{tweakable signature schemes} where a user has a single private key but many public keys, each capable of verifying signatures created with the same private key. This is achieved by separating key generation into two phases:
\begin{enumerate}
\item Private key generation.
\item Public key generation that dependens on a user-chosen index $\iota$.
\end{enumerate}
Tweakable signature schemes have to satisfy two security properties:
\begin{enumerate}
\item \emph{Existential unforgeability}, which is similar to the standard EF-CMA condition for the ordinary signature schemes.
\item \emph{Unlinkability} of keys, i.e. the one-time public keys and the signatures verifiable with one-time keys contain no useful information about whether they correspond to the same private key or not.
\end{enumerate}
We will show that a wide class of generic signature schemes $\mathsf{S}=(G,S,V)$ can
be transformed to tweakable signature schemes $\mathsf{S}^F$ by using a pseudo random function family $F$. This wide class contains, for example all Schnorr type signature schemes (like EdDSA) and DSA type signature schemes like ECDSA (used in Bitcoin). In principle, such a transformation also applies to RSA but is much less efficient.
We will prove that whenever a generic scheme is EF-CMA secure and $F$ is a secure pseudo-random function family, then the tweakable signature scheme $\mathsf{S}^F$ is both existentially unforgeable and unlinkable.

\subsubsection{Definition and Motivation}

\begin{definition}[Tweakable signature scheme]
A tweakable signature scheme is a tuple $(G_s,G_p,S,V)$ such that:
\begin{itemize}
\item $k\gets G_s$ generates the private key
\item $X_\iota\gets G_p(k,\iota)$ generates a (one-time) public key for an index $\iota$
\item $\sigma\gets S(k;\iota,m)$ creates a signature for a message $m$
\item $V(X,m,\sigma)$ verifies a signature $\sigma$ on a message $m$ with public key $X$
\end{itemize}
so that the following verification identity holds for every key $k$, for every message $m$, and for every index $\iota$:
\[
V(G_p(k,\iota),m,S(k;\iota,m))=1\enspace.
\]
\end{definition}
Tweakable signature schemes may be used in payment scenarios, where a payee has the private key $k$ of a tweakable signature scheme
$(G_s,G_p,S,V)$:
\begin{enumerate}
\item The payee first sends an invoice to the payer, where the invoice contains the index $\iota$ as a \emph{reference number} as well as the specific public key $X_\iota =G_p(k,\iota)$. The reference number may depend on the goods or services for which the invoice was sent.
\item The payer forms a transaction $T$ that among the other necessary information contains the reference number $\iota$, signs the transaction with a signature $\sigma$, and sends the signed transaction $(T,\sigma)$ to the payment system (e.g. Bitcoin blockchain).
\item The payee may then check that the signed transaction $(T,\sigma)$ was received by the payment system (for example, is in a sufficiently old Bitcoin block) and that
$T.X_\iota=G_p(k,T.\iota)$. By the explicit reference number $T.\iota$, the payee is also able to check for which goods or services the incoming payment was made.
\end{enumerate}
If the tweakable signature scheme is unlinkable, it is not later possible to determine whether any two signed payment transactions $(T,\sigma), (T',\sigma')$
are associated with the same payee or the same payer.

\subsubsection{Security Definitions}

For the existential unforgeability, we use a formal security condition that is similar to the standard EF-CMA, but where the adversary can itself initiate public key generation and choose the corresponding indices $\iota$ arbitrarily by itself.
The attack scenario involves an oracle $\mathcal{O}^{\tilde{\mathsf{S}}}_k$ that
holds a secret key $k$, has a set $I$ (which is initially empty) as its state, and answers two types of queries:
\begin{itemize}
\item $\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ -- a key generation query that is answered as follows. If $\iota\in I$ the  oracle returns $\bot$ (the index was already used). Otherwise, the oracle sets $I\gets I\cup \{\iota\}$ (marks $\iota$ as "used") and returns $X_\iota = G_p(k,\iota)$.
\item $\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{sig};\iota,m)$ -- a signing query that is answered as follows. If $\iota\not\in I$ the oracle returns $\bot$ (the key $X_\iota$ is not yet generated). Otherwise, the oracle returns $\sigma=S(k;\iota,m)$.
\end{itemize}

\begin{definition}[EF-CKMA]
A tweakable signature scheme $\tilde{\mathsf{S}}=(G_s,G_p,S,V)$ is $s$-secure against existential forgeries under
chosen key-message attack (EF-CKMA) if it has $s$ as a security profile $s$ in the following attack scenario:
\begin{enumerate}
\item $k\gets G_s$
\item $(X,\iota,m,\sigma)\gets A^{\mathcal{O}^{\tilde{\mathsf{S}}}_k}$
\item The attack is successful iff:
\begin{enumerate}
\item $V(X;m,\sigma)=1$
\item The query $X\gets \mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ was made by $A$
\item The query $\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{sig};\iota,m)$ was never made by $A$
\end{enumerate}
The success $\epsilon$ of $A$ is the probability that $A$ is successful.
\end{enumerate}
\end{definition}
For defining the unlinkability, we introduce an additional oracle $\mathcal{O}^{\tilde{\mathsf{S}}}$ that is similar to the first oracle, but handles the
queries as follows:
\begin{itemize}
\item $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{gen};\iota)$ -- a key generation query that is answered as follows. If $\iota\in I$ the  oracle returns $\bot$ (the index was already used). Otherwise, the oracle sets $I\gets I\cup \{\iota\}$ (marks $\iota$ as "used"), generates $k_\iota\gets G_s$, saves $k_\iota$, and returns $X_\iota = G_p(k_\iota,\iota)$.
\item $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{sig};\iota,m)$ -- a signing query that is answered as follows. If $\iota\not\in I$ the  oracle returns $\bot$ (the key $X_\iota$ is not yet generated). Otherwise, the oracle returns $\sigma=S(k_\iota;\iota,m)$.
\end{itemize}
\begin{definition}[Unlikability]\label{def:unlinkability}
A tweakable signature scheme $\tilde{\mathsf{S}}=(G_s,G_p,S,V)$ is $s$-secure unlinkable if is has $s$ as a security profile in the following scenario:
\begin{enumerate}
\item $k\gets G_s$
\item $b_1\gets D^{\mathcal{O}^{\tilde{\mathsf{S}}}_k}$
\item $b_0\gets D^{\mathcal{O}^{\tilde{\mathsf{S}}}}$
\item The success of $D$ is
$\epsilon=|\mathsf{Pr}[b_1=1]-\mathsf{Pr}[b_0=1]|$.
\end{enumerate}
\end{definition}
The idea of the security condition is that a distinguisher $D$ cannot make difference whether the secret key is the same $k$ for all key-generation queries (the oracle $\mathcal{O}^{\tilde{\mathsf{S}}}_k$)
or is generated independently for every (adversary-chosen) index (the oracle $\mathcal{O}^{\tilde{\mathsf{S}}}$).

The oracles are defined so that the queries
$\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ cannot be made twice, i.e. $\bot$ is returned for a repeated query. This restriction is essential, because otherwise $D$ can easily distinguish the oracles: $\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ will always be the same but the public keys generated by calling $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{gen};\iota)$ twice can be different.

\subsubsection{EF-CKMA for Ordinary Signature Schemes}\label{sec:efckma-ordinary}
Before defining a general construction of tweakable signature schemes from ordinary ones, we need to define EF-CKMA security for ordinary signature schemes. For that, we define an additional oracle $\mathcal{O}^{\mathsf{S}}$ that handles the
queries as follows:
\begin{itemize}
\item $\mathcal{O}^{\mathsf{S}}(\mathsf{gen};\iota)$ -- a key generation query that is answered as follows. If $\iota\in I$ the  oracle returns $\bot$ (the index was already used). Otherwise, the oracle sets $I\gets I\cup \{\iota\}$ (marks $\iota$ as "used"), generates $(x_\iota,X_\iota)\gets G$, saves $x_\iota$, and returns $X_\iota$.
\item $\mathcal{O}^{\mathsf{S}}(\mathsf{sig};\iota,m)$ -- a signing query that is answered as follows. If $\iota\not\in I$ the  oracle returns $\bot$ (the key $X_\iota$ is not yet generated). Otherwise, the oracle returns $\sigma=S(x_\iota;m)$.
\end{itemize}



\begin{definition}[EF-CKMA for ordinary signatures]\label{def:efckma-ordinary}
A signature scheme $\mathsf{S}=(G,S,V)$ is $s$-secure EF-CKMA if it has $s$ as a security profile in the following attack scenario:
\begin{enumerate}
\item $(X,\iota,m,\sigma)\gets A^{\mathcal{O}^{\mathsf{S}}}$
\item The attack is successful iff:
\begin{enumerate}
\item $V(X;m,\sigma)=1$
\item The query $X\gets \mathcal{O}^{\mathsf{S}}(\mathsf{gen};\iota)$ was made by $A$.
\item The query $\mathcal{O}^{\mathsf{S}}(\mathsf{sig};\iota,m)$ was never made by $A$.
\end{enumerate}
\end{enumerate}
\end{definition}
EF-CKMA differs from traditional EF-CMA because the adversary is able to initiate the use of new keys and may create an existential forgery with any of the keys. The indices are used just for labelling the generated keys.

It turns out that EF-CKMA is not conceptually stronger notion of security because any EF-CMA signature scheme is also EF-CKMA, though with some security loss.

\begin{theorem}[EF-CMA implies EF-CKMA]
Every signature scheme $\mathsf{S}=(G,S,V)$ that is $s$-secure EF-CMA is $s'$-secure EF-CKMA, where $s'$ is a function for which the implication $\tau(t)\ge s(\epsilon/t) \; \Rightarrow \; t\ge s'(\epsilon)$ holds for every $t$ and $\tau$ is defined by $\tau(t)=(1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t + t_\mathsf{sm}$.
\end{theorem}
\begin{proof}
Given a $t$-time adversary $A$ that has success $\epsilon$ in the EF-CKMA scenario, we construct an EF-CMA adversary $B$ that has success $\epsilon/t$ and running time $\tau(t)$ which means that $\tau(t)\ge s(\epsilon/t)$. The adversary $B^{S(x;\cdot)}(X)$ (where $(x,X)$ is a private-public key pair) proceeds as follows:
\begin{enumerate}
\item Generates a random number $t_0\gets \{1,\ldots,t\}$
\item Simulates $(\iota,X,m,\sigma)\gets A^{\mathcal{O}^\mathsf{S}}$ by answering the $\mathcal{O}^\mathsf{S}$-queries as follows:
\begin{itemize}
\item $\mathcal{O}^\mathsf{S}(\mathsf{gen};\iota)$ -- if this is the $t_0$-th query, set $\iota_0\gets \iota$ and return $X$. Otherwise, compute $(X_\iota,x_\iota)\gets G$ and return $X_\iota$.
\item $\mathcal{O}^\mathsf{S}(\mathsf{sig};\iota,m)$ -- If $\iota_0$ is defined and $\iota=\iota_0$, then query the oracle $\sigma\gets S(x;m)$ and return $\sigma$. Otherwise, if $x_\iota$ is not defined, return $\bot$; and if $x_\iota$ is defined, compute $\sigma \gets S(x_\iota;m)$ and return $\sigma$.
\end{itemize}
\item Returns $(m,\sigma)$.
\end{enumerate}
With probability $\epsilon/t$ the adversary $(\iota,X,m,\sigma)\gets A^{\mathcal{O}^\mathsf{S}}$ succeeds in the simulation so that $\iota=\iota_0$ which means that $B^{S(x;\cdot)}(X)$ succeeds with the same probability in the EF-CMA game. The computational overhead function can be chosen to be $\tau(t)=(1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t + t_\mathsf{sm}$.
\end{proof}

\medskip\medskip
\noindent To illustrate the security loss, assume that $s(\epsilon)=s_\mathsf{cma}\cdot \epsilon$ is a linear function. From $\tau(t)\ge s(\epsilon/t)$ it follows that:
\[
(t_\mathsf{sm}+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t \ge
(1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t + t_\mathsf{sm} \ge s_\mathsf{cma}\cdot \epsilon/t
\]
Hence, $t\ge \sqrt{\frac{s_\mathsf{cma}\cdot \epsilon}{t_\mathsf{sm}+\max\{t_\mathsf{gen},t_\mathsf{sig}\}}}$ and hence, it is sufficient to take \[s'(\epsilon)=\sqrt{\frac{s(\epsilon)}{t_\mathsf{sm}+\max\{t_\mathsf{gen},t_\mathsf{sig}\}}}\enspace.
\]

\subsubsection{Generic Construction and Security Proofs}

In this section, we define a wide class of \emph{tweak-friendly} signature schemes that can be transformed into tweakable signature schemes.

\begin{definition}[Tweak-friendly signature scheme]
A signature scheme is tweak-friendly if the key-generation function $G$ is in the form:
\begin{enumerate}
\item $x\gets \mathcal{X}$
\item $X\gets f(x)$
\item Output $(X,x)$
\end{enumerate}
where $f$ is a deterministic function.
\end{definition}
For example, ECDSA and EdDSA are tweak-friendly, because their keys are generated by the rule: $x\gets \mathbb{Z}_q$, $X=x\mathbf{g}$, where $\mathbf{g}$ is a generator of a cyclic group $\mathbb{G}$ with order $q$, i.e. in that case, $\mathcal{X}=\mathbb{Z}_q$ and $f\colon \mathbb{Z}_q\rightarrow \mathbb{G}$ is defined by  $f(x)=x\mathbf{g}$.


\begin{definition}[Transformed scheme]
Let $\mathsf{S}=(G,S,V)$ be a tweak-friendly signature scheme and $F\colon K\times \mathbb{I} \rightarrow \mathcal{X}$ be a pseudo-random function family.
The transformed scheme $\mathsf{S}^F=(G_s,G_p,S',V)$ is defined as follows:
\begin{itemize}
\item $G_s$ outputs a uniformly random $k\gets K$
\item $G_p(k,\iota)=f(F_k(\iota))$ for every $k\in K$ and $\iota\in \mathbb{I}$
\item $S'(k;\iota,m)=S(F_k(\iota); m)$ for every $k\in K$, $\iota\in \mathbb{I}$, and for every message $m$
\end{itemize}
\end{definition}
It is easy to see that the transformed scheme is a tweakable signature scheme. Note also that in the scenario $k \gets K, x_\iota \gets F_k(\iota), X_\iota\gets G_p(\iota, x_\iota)$
the distribution of $(X_\iota,x_\iota)$ is the same as in the scenario
$(X_\iota,x_\iota)\gets G$.

\begin{theorem}
If $\mathsf{S}=(G,S,V)$ is a tweak-friendly singature scheme and $F$ is an $s$-secure PRF, then the transformed scheme $\tilde{S}=\mathsf{S}^F=(G_s,G_p,S',V)$ is $s'$-
secure unlinkable, where $s'(\epsilon) = \frac{s(\epsilon)}{1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})}$.
\end{theorem}
\begin{proof}
Let $D$ be a $t$-time distinguisher that has success $\epsilon$ in the unlinkability scenario. We construct a distinguisher $\underline{D}$ for $F$ as follows. Given access to an oracle $\varphi(\cdot)$ the distinguisher $\underline{D}^{\varphi(\cdot)}$
proceeds as follows:
\begin{enumerate}
\item Simulates $b\gets D^{\mathcal{O}^{\varphi}}$, where the oracle calls are simulated as follows:
\begin{itemize}
\item $\mathcal{O}^{\varphi}(\mathsf{gen};\iota)$ -- If $\iota\in I$ then return $\bot$. Otherwise, set $I\gets I \cup \{\iota\}$ and return $f(\varphi(\iota))$
\item $\mathcal{O}^{\varphi}(\mathsf{sig};\iota,m)$ -- If $\iota\not\in I$ then return $\bot$. Otherwise, return $S(\varphi(\iota);m)$
\end{itemize}
\item Returns $b$
\end{enumerate}
If $\varphi(\cdot)=F_k(\cdot)$, then the oracle $\mathcal{O}^\varphi$ is equivalent to  $\mathcal{O}^{\tilde{\mathsf{S}}}_k$, because then:
\begin{itemize}
\item $\mathcal{O}^\varphi(\mathsf{gen};\iota) = \mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ as $f(\varphi(\iota)) = f(F_k(\iota))=G_p(k,\iota)$, and
\item
$\mathcal{O}^\varphi(\mathsf{sig};\iota,m) = \mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{sig};\iota,m)$
due to $S(\varphi(\iota);m)=S(F_k(\iota);m)=S'(k;\iota,m)$
\end{itemize}
If $\varphi(\cdot)=\Phi(\cdot)$, then the oracle $\mathcal{O}^\varphi$ is equivalent to  $\mathcal{O}^{\tilde{\mathsf{S}}}$, because then:
\begin{itemize}
\item $\mathcal{O}^\varphi(\mathsf{gen};\iota) = \mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{gen};\iota)$
because
due to lazy sampling technique, computing $f(\varphi(\iota)) = f(\Phi(\iota))$
is equivalent to $k_\iota\gets K\equiv k_\iota\gets G_s$ and returning
$X_\iota = G_p(k_\iota,\iota)$
\item
$\mathcal{O}^\varphi(\mathsf{sig};\iota,m) = \mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{sig};\iota,m)$
due to $S(\varphi(\iota);m)=S(\Phi(\iota);m)=S'(k_\iota;\iota,m)$ in case $k_\iota$ was a saved value during lazy sampling and hence $\Phi(\iota)=k_\iota$.
\end{itemize}
Therefore, the unlinkability scenario with $D$ is equivalent to the PRF scenario with $\underline{D}$ and
hence, the success of $\underline{D}$ in the PRF-scenario is $\epsilon$. As the computational time overhead function is $\tau(t) = (1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t$, the statement of the theorem follows.
\end{proof}

\begin{theorem}
If $\mathsf{S}=(G,S,V)$ is a tweak-friendly singature scheme that is $s$-secure EF-CKMA and
its transformed scheme $\tilde{S}=\mathsf{S}^F=(G_s,G_p,S',V)$ is $s$-secure unlinkable, then
$\tilde{S}$ is $s'$-secure EF-CKMA, where $s'(\epsilon) = s(\epsilon/2)$.
\end{theorem}
\begin{proof}
Let $A^\mathcal{O}$ be a $t$-time oracle adversary that succeeds with probability $\epsilon$ in the EF-CKMA scenario. We construct a distinguisher $D^\mathcal{O}$ for unlinkability and an EF-CKMA adversary $A^\mathcal{O}_\mathsf{ckma}$ for $\mathsf{S}$ as follows:
\begin{itemize}
\item $D^\mathcal{O}$ simulates $(X,\iota,m,\sigma)\gets A^{\mathcal{O}}$ and returns 1 iff $A$ is successful.
\item $A_\mathsf{ckma}^\mathcal{O}$ also simulates $(X,\iota,m,\sigma)\gets A^{\mathcal{O}}$ and returns $(X,\iota,m,\sigma)$.
\end{itemize}
In the EF-CKMA scenario, $k\gets K \equiv k\gets G_s$ is picked uniformly at random and $(X,\iota,m,\sigma)\gets A^{\mathcal{O}^{\tilde{\mathsf{S}}}_k}$ produces existential forgery with probability $\epsilon$. Hence, $\mathsf{Pr}[1\gets D^{\mathcal{O}^{\tilde{\mathsf{S}}}_k}]=\epsilon$. Let $\epsilon'$ be the probability that $(X,\iota,m,\sigma)\gets A^{\mathcal{O}^{\tilde{\mathcal{S}}}}$
produces existential forgery. Hence,
$\mathsf{Pr}[1\gets D^{\mathcal{O}^{\tilde{\mathsf{S}}}}]=\epsilon'$
and the success of $D$ in the unlinkability scenario is $\epsilon_\mathsf{unl}=|\epsilon-\epsilon'|$.
Note also that the oracles $\mathcal{O}^{\tilde{\mathsf{S}}}$ (from Def.~\ref{def:unlinkability}) and $\mathcal{O}^{\mathsf{S}}$ (from Def.~\ref{def:efckma-ordinary}) are equivalent because:
\begin{itemize}
\item $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{gen};\iota) = \mathcal{O}^{\mathsf{S}}(\mathsf{gen};\iota)$ as the scenario
[$k_\iota \gets G_s, X_\iota \gets G_p(k_\iota)$, Return $X_\iota$]
is equivalent to the scenario
[$(x_\iota, X_\iota)\gets G$, Return $X_\iota$].
\item $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{sig};\iota,m) = \mathcal{O}^{\mathsf{S}}(\mathsf{sig};\iota,m)$ as $S'(k_\iota;\iota,m)=S(F_{k_\iota}(\iota);m)=S(x_\iota;m)$.
\end{itemize}
Hence, $A_\mathsf{ckma}^{\mathcal{O}^\mathsf{S}}$
succeeds in the EF-KCMA scenario with probability $\epsilon_\mathsf{ckma}=\epsilon'$.
Therefore, $\epsilon \le \epsilon_\mathsf{unl}+ \epsilon_\mathsf{kcma}$. As the construction of $D$ and $A_\mathsf{ckma}$ involves no computational time overhead, we conclude that
$\tilde{\mathsf{S}}$ is $s'$-secure EF-CKMA with $s'(\epsilon) = s(\epsilon/2)$.
\end{proof}

\subsubsection{Remarks on Practical Implementation}

The main tool in the construction is the pseudo-random function family $F$ and hence the security of the scheme directly depends on the security of $F$ as a PRF.

For the ECDSA and EdDSA with groups the order $q$ of which is much less than $2^{512}$ we may apply the HMAC construction \cite{BeCK96} as follows:
\[
F_k(\iota) = \mathsf{Int}(\mathsf{HMAC}_{\mathsf{sha512}} (k;\iota)) \mod q
\]
where $\mathsf{Int}\colon \{0,1\}^{512}\rightarrow \mathbb{Z}_{2^{512}}$ converts bitstrings to non-negative integers, $k\gets K=\{0,1\}^{m}$, and $\iota\in\mathbb{I}=\{0,1\}^{64}$.
If
%$m$ is sufficiently large (say $m=512$) and
$q\ll 2^{512}$, then the output distribution
of $F_k(\cdot)$ is almost as indistinguishable
from the uniform distribution $U_q$ on $\mathbb{Z}_{q}$ as the output distribution of $\mathsf{HMAC}_{\mathsf{sha512}} (k;\cdot)$ from the uniform distribution $U_{2^{512}}$ on $\{0,1\}^{512}$
because the statistical distance between
$U_q$ and the distribution  $\mathsf{Int}(U_{2^{512}})\!\!\mod q$ has an upper bound $\frac{q}{2^{513}}$.

In \cite{Bell15}, Bellare proved that HMAC is a PRF if the compression function (of the hash function) is a PRF, which is a good practical security guarantee since no efficient attacks are known against the PRF-security of the compression function.

\subsection{A Solution for ECDSA}

Unlike the rest of the paper which is not signature scheme specific, we are assuming the ECDSA signature scheme in the following subsections, and using the ECDSA, DH specific notation.

\subsubsection{Interactive Protocol}

The recipient holds a persistent keypair $(d, P)$ where $P = d \cdot G$ with generator $G$ and order $n$. For each transaction, the recipient generates an ephemeral blinding factor $r \gets \mathbb{Z}_n$ and derives a transaction-specific public key $P' = (d + r) \cdot G$. The protocol is shown in Figure~\ref{fig:protocol1}.


\begin{figure}[!htb]
\centering
\fbox{
\begin{minipage}{0.9\textwidth}

\underline{Setup:} Recipient holds persistent keypair $(d, P)$ where $P = d \cdot G$

\vspace{3mm}
\begin{tabular}{lcl}
\textbf{Sender} & & \textbf{Recipient}\\
\hline
\\[-2mm]
  & &$r \stackrel{\$}{\gets} \mathbb{Z}_n$  \\
  & & $P_{tx} \gets (d + r) \cdot G$  \\
  & & $R \gets r \cdot G$  \\
  & $\xleftarrow{\hspace{1cm} (P_{tx}, R) \hspace{1cm}}$ & \\
$\mathsf{tx} \gets \{P_{tx}, R, \ldots\}$  & &  \\
  & $\xrightarrow{\hspace{1.5cm} \mathsf{tx} \hspace{1.5cm}}$ & \\
  & & $r' \gets \mathcal{H}(d \,||\, R)$ \\
  & & $d_{tx} \gets d + r' \bmod n$ \\
  & & $\sigma \gets \mathsf{Sign}(d_{tx}; \mathsf{tx}_{next})$ \\
\end{tabular}
\end{minipage}
}
\caption{Interactive protocol for generating unlinkable ECDSA public keys.}
\label{fig:protocol1}
\end{figure}

The recipient maintains only the persistent secret $d$ and derives ephemeral signing keys deterministically from metadata $R$, included in the auxiliary data $\auxd$ of the transaction. When spending the token, the recipient reconstructs the blinding factor $r' = H(d \,||\, R)$ and derives the private key $d' = d + r' \bmod n$ corresponding to $P'$.

\subsubsection{Non-Interactive Protocol}

For applications requiring persistent public keys as ``addresses'', or non-interactive operation, the parties can create the blinded public key using Diffie-Hellman key exchange. The recipient publishes a persistent public key $P = d \cdot G$. The protocol is shown in Figure~\ref{fig:protocol3}.

The key challenge in non-interactive protocols is protecting against malicious senders who might choose predictable ephemeral keys $r$ or leak them to compromise transaction unlinkability. The secure construction addresses this by binding the blinding factor to both the shared Diffie-Hellman secret and public transaction data.

\begin{figure}[ht]
\centering
\fbox{
\begin{minipage}{0.95\textwidth}

\underline{Setup:}
Recipient has persistent keypair $(d, P = d \cdot G)$ and publishes $P$

\vspace{3mm}
\begin{tabular}{lcl}
\textbf{Sender} & & \textbf{Recipient} \\
\hline
\\[-2mm]
$r \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$ & & \\
$R \leftarrow r \cdot G$ & & \\
$s \leftarrow \mathcal{H}_1(r \cdot P \,||\, R \,||\, \mathsf{tx}_{prev})$ & & \\
$P_{tx} \leftarrow P + s \cdot G$ & & \\
$\mathsf{tx} \leftarrow \{P_{tx}, R, \dots\}$ & & \\
& $\xrightarrow{\hspace{.6cm} \mathsf{tx} \hspace{.6cm}}$ & \\[3mm]
& & \textbf{if} $R = \mathcal{O}$ \textbf{then abort} \\
& & $s' \leftarrow \mathcal{H}_1(d \cdot R \,||\, R \,||\, \mathsf{tx}_{prev})$ \\
& & \textbf{if} $P + s' \cdot G \neq P_{tx}$ \textbf{then abort} \\
& & $d_{tx} \leftarrow d + s' \bmod n$ \\
& & \textit{Sign next transaction using} $d_{tx}$ \\
\end{tabular}
\end{minipage}
}
\caption{Non-interactive protocol secure against malicious sender.}
\label{fig:protocol3}
\end{figure}

The sender generates an ephemeral keypair $(r, R = r \cdot G)$ and computes a Diffie-Hellman shared secret $r \cdot P$. The blinding factor $s$ is derived by hashing the shared secret together with the ephemeral public key $R$ and the previous transaction identifier $\mathsf{tx}_{prev}$:
$$s = \mathcal{H}_1(r \cdot P \,||\, R \,||\, \mathsf{tx}_{prev})$$

The transaction-specific public key is computed as $P_{tx} = P + s \cdot G$, and both $P_{tx}$ and $R$ are included in the transaction. Upon receiving the transaction, the recipient:
\begin{enumerate}
\item Verifies that $R \neq \mathcal{O}$ (the point at infinity) to prevent trivial attacks
\item Computes the same shared secret $d \cdot R = r \cdot P$ using their persistent private key
\item Derives $s' = \mathcal{H}_1(d \cdot R \,||\, R \,||\, \mathsf{tx}_{prev})$ and verifies that $P + s' \cdot G = P_{tx}$
\item Computes the transaction-specific private key $d_{tx} = d + s' \bmod n$ for signing the next transaction
\end{enumerate}

By including both $R$ and $\mathsf{tx}_{prev}$ in the hash input, the protocol ensures that:
\begin{itemize}
\item Even if the sender chooses a predictable $r$, the blinding factor $s$ depends on the hash function output and remains unpredictable to external observers
\item The recipient can verify that the sender correctly computed $P_{tx}$ without learning $r$
\item Each transaction uses a unique blinding factor (assuming $\mathsf{tx}_{prev}$ is always unique), preventing linkability even if the sender reuses the same $r$ across different transactions
\end{itemize}

We assume that $\mathsf{tx}_{prev}$ is always unique, as a malicious sender reusing the exact $(r, \mathsf{tx}_{prev})$ pair could break unlinkability. In practice, $\mathsf{tx}_{prev}$ can be the hash of the previous transaction or a timestamp with sufficient granularity.


\subsubsection{Desired Privacy Properties:}

\begin{enumerate}
\item \textbf{Transaction Identity Unlinkability:}
For any two transactions $\mathsf{tx}_i, \mathsf{tx}_j$ with $i \neq j$:
$$\text{Dist}[(P_{tx,i}, R_i)] \approx_c \text{Dist}[(U_1, U_2)]$$
where $U_1, U_2 \stackrel{\$}{\leftarrow} \mathbb{G}$ are uniform random group elements.

\textit{Informally:} The ownership-related fields in each transaction appear as uniformly random data. The pair $(P_{tx}, R)$ in any transaction is computationally indistinguishable from two random group elements, making all transactions unlinkable to each other and to any recipient addresses.

\item \textbf{Forward Privacy:}
Given $d_{tx,i} = d_i + \mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$:
$$\Pr\left[\mathcal{A}(d_{tx,i}, \{\mathsf{tx}_j\}_{j=1}^n) \rightarrow d_i\right] \leq \text{negl}(\lambda)$$

\textit{Informally:} If a transaction-specific private key $d_{tx,i}$ is compromised (e.g., leaked or extracted from a device), the adversary cannot recover the recipient's persistent private key $d_i$. This ensures that past key exposures do not compromise the recipient's persistent identity or future transactions.
\end{enumerate}

\textbf{Remark:} Transaction Identity Unlinkability implies several important corollaries:
\begin{itemize}
\item \emph{Address Unlinkability:} An adversary observing a transaction cannot determine which of two candidate recipients it was sent to, beyond random guessing. This follows immediately since if $(P_{tx}, R)$ is pseudorandom, it reveals no information about the underlying persistent address $P$.

\item \emph{Recipient Unlinkability:} An adversary observing multiple transactions cannot determine which transactions belong to the same recipient. Even when a recipient reuses their persistent public key $P$ across multiple transactions, the resulting transaction-specific keys appear independent and uniformly random.
\end{itemize}

\subsubsection{Cryptographic Assumptions}

For the privacy proofs, we require the following standard cryptographic assumptions in the elliptic curve group $\mathbb{G}$ of prime order $n$ with generator $G$:

\begin{definition}[Decisional Diffie-Hellman (DDH)]
The DDH problem is $S$-hard in $\mathbb{G}$ if it has $S$ as a security profile in the following distinguishing scenario:
\begin{enumerate}
\item Sample $a, b, c \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$ and $d \stackrel{\$}{\leftarrow} \{0,1\}$
\item If $d = 0$: set $T \leftarrow (a \cdot G, b \cdot G, ab \cdot G)$
\item If $d = 1$: set $T \leftarrow (a \cdot G, b \cdot G, c \cdot G)$
\item $d' \gets \mathcal{A}(T)$
\item The attack is successful iff $d' = d$
\end{enumerate}
The advantage is $\text{Adv}^{\text{DDH}}_{\mathcal{A}} = \left|\Pr[d' = d] - \frac{1}{2}\right|$.
\end{definition}

\begin{definition}[Discrete Logarithm (DL)]
The DL problem is $S$-hard in $\mathbb{G}$ if it has $S$ as a security profile in the following attack scenario:
\begin{enumerate}
\item $x \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$, $X \leftarrow x \cdot G$
\item $x' \gets \mathcal{A}(X)$
\item The attack is successful iff $x' = x$
\end{enumerate}
\end{definition}

We model $\mathcal{H}_1 \colon \mathbb{G} \times \mathbb{G} \times \mathcal{M} \to \mathbb{Z}_n$ as a hash function with standard collision-resistance and additional properties suitable for key derivation.

\subsubsection{Privacy Proofs}

\begin{theorem}[Transaction Identity Unlinkability]
\label{thm:transaction-unlinkability}
If the DDH problem is $S$-hard in $\mathbb{G}$ and $\mathcal{H}_1$ is modeled as a random oracle, then the protocol in Fig.~\ref{fig:protocol3} satisfies transaction identity unlinkability. Specifically, for any two transactions $\mathsf{tx}_i, \mathsf{tx}_j$ with $i \neq j$:
$$\text{Dist}[(P_{tx,i}, R_i)] \approx_c \text{Dist}[(U_1, U_2)]$$
where $U_1, U_2 \stackrel{\$}{\leftarrow} \mathbb{G}$ are uniformly random, with distinguishing advantage at most $\text{Adv}^{\text{DDH}}_{\mathcal{A}} + \frac{q_H}{n}$ where $q_H$ is the number of hash queries.
\end{theorem}

\begin{proof}
For transaction $\mathsf{tx}_i$, the sender chooses $r_i \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$ and computes:
\begin{align*}
R_i &= r_i \cdot G \\
s_i &= \mathcal{H}_1(r_i \cdot P_i \,||\, R_i \,||\, \mathsf{tx}_{i-1}) \\
P_{tx,i} &= P_i + s_i \cdot G
\end{align*}

We use a game-based argument to show that $(P_{tx,i}, R_i)$ is indistinguishable from $(U_1, U_2)$ where $U_1, U_2 \stackrel{\$}{\leftarrow} \mathbb{G}$.

\textbf{Game 0:} The real transaction generation process as described above.

\textbf{Game 1:} Replace $s_i = \mathcal{H}_1(r_i \cdot P_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$ with a uniformly random $s_i \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$.

\noindent\textit{Claim:} $|\Pr[\text{Game 0}] - \Pr[\text{Game 1}]| \leq \text{Adv}^{\text{DDH}}_{\mathcal{A}} + \frac{q_H}{n}$.

Consider the tuple $(P_i, R_i, r_i \cdot P_i) = (d_i \cdot G, r_i \cdot G, r_i d_i \cdot G)$. Under the DDH assumption, this is computationally indistinguishable from $(d_i \cdot G, r_i \cdot G, c \cdot G)$ where $c \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$. Since $\mathcal{H}_1$ is modeled as a random oracle and $\mathsf{tx}_{i-1}$ is unique (by assumption), if the adversary does not query $\mathcal{H}_1(r_i \cdot P_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$, the value $s_i$ is uniformly random. The probability of guessing the correct input is at most $\frac{q_H}{n}$.

\textbf{Game 1 Analysis:} Since $r_i$ is chosen uniformly at random, $R_i = r_i \cdot G$ is uniformly distributed in $\mathbb{G}$. Given that $s_i \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$ is uniformly random and independent, $P_{tx,i} = P_i + s_i \cdot G$ is uniformly distributed in $\mathbb{G}$, since adding a uniformly random scalar times the generator to any group element yields a uniformly random element.

Therefore, in Game 1, $(P_{tx,i}, R_i)$ has the same distribution as two independent uniformly random group elements $(U_1, U_2)$.

Since this holds for each transaction independently (with fresh randomness $r_i$ for each transaction), the identity data in all transactions is unlinkable.
\end{proof}

\begin{theorem}[Forward Privacy]
\label{thm:forward-privacy}
If the discrete logarithm problem is $S$-hard in $\mathbb{G}$ and $\mathcal{H}_1$ is modeled as a random oracle, then for any PPT adversary $\mathcal{A}$:
$$\Pr\left[\mathcal{A}(d_{tx,i}, \{\mathsf{tx}_j\}_{j=1}^n) \rightarrow d_i\right] \leq \text{Adv}^{\text{DL}}_{\mathcal{A}} + \frac{q_H}{n}$$
where $d_{tx,i} = d_i + s_i \bmod n$ and $s_i = \mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$.
\end{theorem}

\begin{proof}
The recipient's transaction-specific private key is:
$$d_{tx,i} = d_i + s_i \bmod n$$
where $s_i = \mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$.

To recover $d_i$ from $d_{tx,i}$, the adversary must compute $s_i$, since:
$$d_i = d_{tx,i} - s_i \bmod n$$

Computing $s_i$ requires evaluating $\mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$, which in turn requires computing the shared secret $d_i \cdot R_i = d_i r_i \cdot G$.

The adversary observes:
\begin{itemize}
\item $R_i = r_i \cdot G$ (from the transaction)
\item $P_i = d_i \cdot G$ (possibly inferred or public, though unlinkable by Theorem~\ref{thm:transaction-unlinkability})
\item $d_{tx,i}$ (the leaked transaction key)
\end{itemize}

\textbf{Case 1:} The adversary does not query $\mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$.

Since $\mathcal{H}_1$ is a random oracle, without querying the correct input, $s_i$ appears uniformly random in $\mathbb{Z}_n$. Given $d_{tx,i} = d_i + s_i \bmod n$ where $s_i$ is unknown and uniform, the value $d_i$ is information-theoretically hidden. The adversary can succeed only by guessing among $q_H$ hash queries, with probability at most $\frac{q_H}{n}$.

\textbf{Case 2:} The adversary queries $\mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$.

To make this query, the adversary must compute $d_i \cdot R_i = d_i r_i \cdot G$ from $P_i = d_i \cdot G$ and $R_i = r_i \cdot G$. This is precisely the Computational Diffie-Hellman (CDH) problem, which is at least as hard as the discrete logarithm problem. If the adversary can compute $d_i \cdot R_i$, they can use the discrete logarithm oracle to extract $d_i$ from $P_i$ (or $r_i$ from $R_i$), succeeding with probability at most $\text{Adv}^{\text{DL}}_{\mathcal{A}}$.

Combining both cases, the adversary's advantage in recovering $d_i$ is bounded by $\text{Adv}^{\text{DL}}_{\mathcal{A}} + \frac{q_H}{n}$, which is negligible.
\end{proof}

\subsubsection{Remarks on Standard Model}

The proofs above use $\mathcal{H}_1$ as a random oracle. To achieve standard model security, we propose the following adjustment:

\textbf{Adjustment:} Replace the hash function $\mathcal{H}_1$ with a key derivation function (KDF) based on a pseudorandom function (PRF) family $\{f_k\}_{k \in \mathcal{K}}$ combined with randomness extraction. Specifically:
\begin{enumerate}
\item Use a randomness extractor $\text{Ext} \colon \mathbb{G} \to \{0,1\}^\lambda$ based on a strong randomness extractor (e.g., leftmost bits of the $x$-coordinate under suitable encoding).
\item Define $s \leftarrow \text{PRF}(\text{Ext}(r \cdot P), R \,||\, \mathsf{tx}_{prev})$ where PRF is a pseudorandom function.
\end{enumerate}

Under the DDH assumption, the value $r \cdot P$ is pseudorandom (given $r \cdot G$ and $P$), and thus $\text{Ext}(r \cdot P)$ serves as a pseudorandom key for the PRF. The PRF output is then pseudorandom, providing similar guarantees to the random oracle model.

With this adjustment, the proofs can be adapted to the standard model by replacing random oracle arguments with PRF indistinguishability under DDH, at the cost of slightly more complex security reductions and stronger assumptions on the randomness extractor properties.


\begin{thebibliography}{99}
\bibitem{Bell15} Bellare, M.: New proofs for NMAC and HMAC: Security without collision resistance.  \emph{Journal of Cryptology} 28, 844--878 (2015)

\bibitem{BeCK96}
Bellare, M., Canetti, R., Krawczyk, H.: Keying hash functions for message authentication.
In: Koblitz, N. (Ed.) CRYPTO’96. LNCS 1109, pp. 1--15 (1996)
\end{thebibliography}

\pagebreak
\appendix
\section{Detailed Transaction Sequence Diagram}

\begin{figure}[!h]
    \begin{center}
        \begin{sequencediagram}
            \newthread{S}{Sender}
            \newinst[3]{R}{Recipient}
            \newinst[2]{US}{Unicity Service}

            % Recipient generates keys and parameters
            \begin{call}{R}{$(\pubkey', \prikey') \gets \keygen$}{R}{}
            \end{call}

            % Recipient sends public key to sender
            \begin{messcall}{R}{$\pubkey'$}{S}
            \end{messcall}

            % Sender creates transaction data
            \postlevel
            \postlevel
            \postlevel
            \begin{call}{S}{\shortstack[l]{
                    $x \gets \{0,1\}^\ell$     \\
                    $D = (\pubkey', x, \auxd)$ \\
                    $T = (\sthash, D)$         \\
                    $(\txhash, d) \gets \commit(H(D))$ \\
                    $h_T = H(\sthash, \txhash)$ \\
                    $\sigma \gets \sig(\prikey, h_T)$
                }
                }{S}{}
            \end{call}

            % Sender requests certification from Unicity Service
            \begin{messcall}{S}{$Q = (\pubkey, \sthash, \txhash, \sigma)$}{US}
                \postlevel
                \begin{call}{US}{\shortstack[l]{
                    $\sigver(\pubkey, h_T, \sigma) \stackrel{?}{=} 1$ \\
                    $R[H(\pubkey, \sthash)] \stackrel{?}{=} \bot$ \\
                    $R[H(\pubkey, \sthash)] \gets \txhash$
                    }}{US}{}
                \end{call}
            \end{messcall}
            \prelevel
            \begin{messcall}{US}{$\pinc$}{S}
            \end{messcall}

            % Sender sends certified transaction to recipient
            \begin{messcall}{S}{$(T, \sigma, \txhash, d, \pinc)$}{R}
                \postlevel
                \postlevel
                \postlevel
                \begin{call}{R}{\shortstack[l]{
                    $T.\sthash \stackrel{?}{=} \sthash$ \\
                    $\open(\txhash, d) \stackrel{?}{=} H(T.D)$ \\
                    $\sigver(\pubkey, H(\sthash, \txhash), \sigma) \stackrel{?}{=} 1$ \\
                    $\univer(H(\pubkey, T.\sthash), \txhash, \pinc) \stackrel{?}{=} 1$ \\
                    Accept transaction if all checks pass
                    }}{R}{}
                \end{call}
            \end{messcall}
        \end{sequencediagram}
        \caption{Detailed Unicity transaction flow.}\label{fi:unicity-transaction-full}
    \end{center}
\end{figure}

\end{document}
