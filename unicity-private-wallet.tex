\section{User Side Privacy}\label{sec:wallet-privacy}


In the previous sections, there is the assumption that the recipient generates a fresh keypair for every transaction. This may be impractical in some applications, especially where the recipient's secure storage is limited. We present two solutions that allow for the generation of unlinkable public keys while maintaining only a single persistent private key.

As a requirement, we avoid the persistent state on the client side that must be retained between transactions.

\subsection{A General Solution using Pseudo-Random Functions}

In this subsection, we define \emph{multi public key (MPK) signature schemes} where a user has a single private key but many public keys, each capable of verifying signatures created with the same private key. This is achieved by separating key generation into two phases:
\begin{enumerate}
\item Private key generation.
\item Public key generation that depends on a user-chosen index $\iota$.
\end{enumerate}
MPK signature schemes have to satisfy two security properties:
\begin{enumerate}
\item \emph{Existential unforgeability}, which is similar to the standard EF-CMA condition for the ordinary signature schemes.
\item \emph{Unlinkability} of keys, i.e. the one-time public keys and the signatures verifiable with one-time keys contain no useful information about whether they correspond to the same private key or not.
\end{enumerate}
We will show that a wide class of generic signature schemes $\mathsf{S}=(G,S,V)$ can
be transformed to MPK signature schemes $\mathsf{S}^F$ by using a pseudo random function family $F$. This wide class contains, for example all Schnorr type signature schemes (like EdDSA) and DSA type signature schemes like ECDSA (used in Bitcoin). In principle, such a transformation also applies to RSA but is much less efficient.
We will prove that whenever a generic scheme is EF-CMA secure and $F$ is a secure pseudo-random function family, then the MPK signature scheme $\mathsf{S}^F$ is both existentially unforgeable and unlinkable.

\subsubsection{Definition and Motivation}

\begin{definition}[MPK signature scheme]
A multi public key (MPK) signature scheme is a tuple $(G_s,G_p,S,V)$ such that:
\begin{itemize}
\item $k\gets G_s$ generates the private key
\item $X_\iota\gets G_p(k,\iota)$ generates a (one-time) public key for an index $\iota$
\item $\sigma\gets S(k;\iota,m)$ creates a signature for a message $m$
\item $V(X,m,\sigma)$ verifies a signature $\sigma$ on a message $m$ with public key $X$
\end{itemize}
so that the following verification identity holds for every key $k$, for every message $m$, and for every index $\iota$:
\[
V(G_p(k,\iota),m,S(k;\iota,m))=1\enspace.
\]
\end{definition}
MPK signature schemes may be used in payment scenarios, where a payee has the private key $k$ of a MPK signature scheme
$(G_s,G_p,S,V)$:
\begin{enumerate}
\item The payee first sends an invoice to the payer, where the invoice contains the index $\iota$ as a \emph{reference number} as well as the specific public key $X_\iota =G_p(k,\iota)$. The reference number may depend on the goods or services for which the invoice was sent.
\item The payer forms a transaction $T$ that among the other necessary information contains the reference number $\iota$, signs the transaction with a signature $\sigma$, and sends the signed transaction $(T,\sigma)$ to the payment system (e.g. Bitcoin blockchain).
\item The payee may then check that the signed transaction $(T,\sigma)$ was received by the payment system (for example, is in a sufficiently old Bitcoin block) and that
$T.X_\iota=G_p(k,T.\iota)$. By the explicit reference number $T.\iota$, the payee is also able to check for which goods or services the incoming payment was made.
\end{enumerate}
If the MPK signature scheme is unlinkable, it is not later possible to determine whether any two signed payment transactions $(T,\sigma), (T',\sigma')$
are associated with the same payee or the same payer.

\subsubsection{Security Definitions}

For the existential unforgeability, we use a formal security condition that is similar to the standard EF-CMA, but where the adversary can itself initiate public key generation and choose the corresponding indices $\iota$ arbitrarily by itself.
The attack scenario involves an oracle $\mathcal{O}^{\tilde{\mathsf{S}}}_k$ that
holds a secret key $k$, has a set $I$ (which is initially empty) as its state, and answers two types of queries:
\begin{itemize}
\item $\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ -- a key generation query that is answered as follows. If $\iota\in I$ the  oracle returns $\bot$ (the index was already used). Otherwise, the oracle sets $I\gets I\cup \{\iota\}$ (marks $\iota$ as "used") and returns $X_\iota = G_p(k,\iota)$.
\item $\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{sig};\iota,m)$ -- a signing query that is answered as follows. If $\iota\not\in I$ the oracle returns $\bot$ (the key $X_\iota$ is not yet generated). Otherwise, the oracle returns $\sigma=S(k;\iota,m)$.
\end{itemize}

\begin{definition}[EF-CKMA]
A MPK signature scheme $\tilde{\mathsf{S}}=(G_s,G_p,S,V)$ is $s$-secure against existential forgeries under
chosen key-message attack (EF-CKMA) if it has $s$ as a security profile $s$ in the following attack scenario:
\begin{enumerate}
\item $k\gets G_s$
\item $(X,\iota,m,\sigma)\gets A^{\mathcal{O}^{\tilde{\mathsf{S}}}_k}$
\item The attack is successful iff:
\begin{enumerate}
\item $V(X;m,\sigma)=1$
\item The query $X\gets \mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ was made by $A$
\item The query $\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{sig};\iota,m)$ was never made by $A$
\end{enumerate}
The success $\epsilon$ of $A$ is the probability that $A$ is successful.
\end{enumerate}
\end{definition}
For defining the unlinkability, we introduce an additional oracle $\mathcal{O}^{\tilde{\mathsf{S}}}$ that is similar to the first oracle, but handles
queries as follows:
\begin{itemize}
\item $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{gen};\iota)$ -- a key generation query that is answered as follows. If $\iota\in I$, the oracle returns $\bot$ (the index was already used). Otherwise, the oracle sets $I\gets I\cup \{\iota\}$ (marks $\iota$ as "used"), generates $k_\iota\gets G_s$, saves $k_\iota$, and returns $X_\iota = G_p(k_\iota,\iota)$.
\item $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{sig};\iota,m)$ -- a signing query that is answered as follows. If $\iota\not\in I$ the oracle returns $\bot$ (the key $X_\iota$ is not yet generated). Otherwise, the oracle returns $\sigma=S(k_\iota;\iota,m)$.
\end{itemize}
\begin{definition}[Unlikability]\label{def:unlinkability}
A MPK signature scheme $\tilde{\mathsf{S}}=(G_s,G_p,S,V)$ is $s$-secure unlinkable if it has $s$ as a security profile in the following scenario:
\begin{enumerate}
\item $k\gets G_s$
\item $b_1\gets D^{\mathcal{O}^{\tilde{\mathsf{S}}}_k}$
\item $b_0\gets D^{\mathcal{O}^{\tilde{\mathsf{S}}}}$
\item The success of $D$ is
$\epsilon=|\mathsf{Pr}[b_1=1]-\mathsf{Pr}[b_0=1]|$.
\end{enumerate}
\end{definition}
The idea of the security condition is that a distinguisher $D$ cannot make difference whether the secret key is the same $k$ for all key-generation queries (the oracle $\mathcal{O}^{\tilde{\mathsf{S}}}_k$)
or is generated independently for every (adversary-chosen) index (the oracle $\mathcal{O}^{\tilde{\mathsf{S}}}$).

The oracles are defined so that the queries
$\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ cannot be made twice, i.e. $\bot$ is returned for a repeated query. This restriction is essential because otherwise $D$ can easily distinguish the oracles: $\mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ will always be the same, but the public keys generated by calling $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{gen};\iota)$ twice can be different.

\subsubsection{EF-CKMA for Ordinary Signature Schemes}\label{sec:efckma-ordinary}
Before defining a general construction of MPK signature schemes from ordinary ones, we need to define EF-CKMA security for ordinary signature schemes. For that, we define an additional oracle $\mathcal{O}^{\mathsf{S}}$ that handles the
queries as follows:
\begin{itemize}
\item $\mathcal{O}^{\mathsf{S}}(\mathsf{gen};\iota)$ -- a key generation query that is answered as follows. If $\iota\in I$, the  oracle returns $\bot$ (the index was already used). Otherwise, the oracle sets $I\gets I\cup \{\iota\}$ (marks $\iota$ as "used"), generates $(x_\iota,X_\iota)\gets G$, saves $x_\iota$, and returns $X_\iota$.
\item $\mathcal{O}^{\mathsf{S}}(\mathsf{sig};\iota,m)$ -- a signing query that is answered as follows. If $\iota\not\in I$ the oracle returns $\bot$ (the key $X_\iota$ is not yet generated). Otherwise, the oracle returns $\sigma=S(x_\iota;m)$.
\end{itemize}



\begin{definition}[EF-CKMA for ordinary signatures]\label{def:efckma-ordinary}
A signature scheme $\mathsf{S}=(G,S,V)$ is $s$-secure EF-CKMA if it has $s$ as a security profile in the following attack scenario:
\begin{enumerate}
\item $(X,\iota,m,\sigma)\gets A^{\mathcal{O}^{\mathsf{S}}}$
\item The attack is successful iff:
\begin{enumerate}
\item $V(X;m,\sigma)=1$
\item The query $X\gets \mathcal{O}^{\mathsf{S}}(\mathsf{gen};\iota)$ was made by $A$.
\item The query $\mathcal{O}^{\mathsf{S}}(\mathsf{sig};\iota,m)$ was never made by $A$.
\end{enumerate}
\end{enumerate}
\end{definition}
EF-CKMA differs from traditional EF-CMA because the adversary is able to initiate the use of new keys and may create an existential forgery with any of the keys. The indices are used just for labeling the generated keys.

It turns out that EF-CKMA is not a conceptually stronger notion of security because any EF-CMA signature scheme is also EF-CKMA, though with some security loss.

\begin{theorem}[EF-CMA implies EF-CKMA]
Every signature scheme $\mathsf{S}=(G,S,V)$ that is $s$-secure EF-CMA is $s'$-secure EF-CKMA, where $s'$ is a function for which the implication $\tau(t)\ge s(\epsilon/t) \; \Rightarrow \; t\ge s'(\epsilon)$ holds for every $t$ and $\tau$ is defined by $\tau(t)=(1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t + t_\mathsf{sm}$.
\end{theorem}
\begin{proof}
Given a $t$-time adversary $A$ that has success $\epsilon$ in the EF-CKMA scenario, we construct an EF-CMA adversary $B$ that has success $\epsilon/t$ and running time $\tau(t)$, which means that $\tau(t)\ge s(\epsilon/t)$. The adversary $B^{S(x;\cdot)}(X)$ (where $(x,X)$ is a private-public key pair) proceeds as follows:
\begin{enumerate}
\item Generates a random number $t_0\gets \{1,\ldots,t\}$
\item Simulates $(\iota,X,m,\sigma)\gets A^{\mathcal{O}^\mathsf{S}}$ by answering the $\mathcal{O}^\mathsf{S}$-queries as follows:
\begin{itemize}
\item $\mathcal{O}^\mathsf{S}(\mathsf{gen};\iota)$ -- if this is the $t_0$-th query, set $\iota_0\gets \iota$ and return $X$. Otherwise, compute $(X_\iota,x_\iota)\gets G$ and return $X_\iota$.
\item $\mathcal{O}^\mathsf{S}(\mathsf{sig};\iota,m)$ -- If $\iota_0$ is defined and $\iota=\iota_0$, then query the oracle $\sigma\gets S(x;m)$ and return $\sigma$. Otherwise, if $x_\iota$ is not defined, return $\bot$; and if $x_\iota$ is defined, compute $\sigma \gets S(x_\iota;m)$ and return $\sigma$.
\end{itemize}
\item Returns $(m,\sigma)$.
\end{enumerate}
With probability $\epsilon/t$ the adversary $(\iota,X,m,\sigma)\gets A^{\mathcal{O}^\mathsf{S}}$ succeeds in the simulation so that $\iota=\iota_0$ which means that $B^{S(x;\cdot)}(X)$ succeeds with the same probability in the EF-CMA game. The computational overhead function can be chosen to be $\tau(t)=(1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t + t_\mathsf{sm}$.
\end{proof}

\medskip\medskip
\noindent To illustrate the security loss, assume that $s(\epsilon)=s_\mathsf{cma}\cdot \epsilon$ is a linear function. From $\tau(t)\ge s(\epsilon/t)$ it follows that:
\[
(t_\mathsf{sm}+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t \ge
(1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t + t_\mathsf{sm} \ge s_\mathsf{cma}\cdot \epsilon/t
\]
Hence, $t\ge \sqrt{\frac{s_\mathsf{cma}\cdot \epsilon}{t_\mathsf{sm}+\max\{t_\mathsf{gen},t_\mathsf{sig}\}}}$ and hence it is sufficient to take \[s'(\epsilon)=\sqrt{\frac{s(\epsilon)}{t_\mathsf{sm}+\max\{t_\mathsf{gen},t_\mathsf{sig}\}}}\enspace.
\]

\subsubsection{Generic Construction and Security Proofs}

In this section, we define a wide class of \emph{MPK-friendly} signature schemes that can be transformed into MPK signature schemes.

\begin{definition}[MPK-friendly signature scheme]
A signature scheme is MPK-friendly if the key-generation function $G$ is in the form:
\begin{enumerate}
\item $x\gets \mathcal{X}$
\item $X\gets f(x)$
\item Output $(X,x)$
\end{enumerate}
where $f$ is a deterministic function.
\end{definition}
For example, ECDSA and EdDSA are MPK-friendly, because their keys are generated by the rule: $x\gets \mathbb{Z}_q$, $X=x\mathbf{g}$, where $\mathbf{g}$ is a generator of a cyclic group $\mathbb{G}$ with order $q$, i.e. in that case, $\mathcal{X}=\mathbb{Z}_q$ and $f\colon \mathbb{Z}_q\rightarrow \mathbb{G}$ is defined by  $f(x)=x\mathbf{g}$.


\begin{definition}[Transformed scheme]

Let $\mathsf{S}=(G,S,V)$ be a MPK-friendly signature scheme, and $F\colon K\times \mathbb{I} \rightarrow \mathcal{X}$ be a pseudo-random function family.
The transformed scheme $\mathsf{S}^F=(G_s,G_p,S',V)$ is defined as follows:
\begin{itemize}
\item $G_s$ outputs a uniformly random $k\gets K$
\item $G_p(k,\iota)=f(F_k(\iota))$ for every $k\in K$ and $\iota\in \mathbb{I}$
\item $S'(k;\iota,m)=S(F_k(\iota); m)$ for every $k\in K$, $\iota\in \mathbb{I}$, and for every message $m$
\end{itemize}
\end{definition}
It is easy to see that the transformed scheme is a MPK signature scheme. Note also that in the scenario $k \gets K, x_\iota \gets F_k(\iota), X_\iota\gets G_p(\iota, x_\iota)$
the distribution of $(X_\iota,x_\iota)$ is the same as in the scenario
$(X_\iota,x_\iota)\gets G$.

\begin{theorem}
If $\mathsf{S}=(G,S,V)$ is a MPK-friendly signature scheme and $F$ is an $s$-secure PRF, then the transformed scheme $\tilde{S}=\mathsf{S}^F=(G_s,G_p,S',V)$ is $s'$-secure unlinkable, where $s'(\epsilon) = \frac{s(\epsilon)}{1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})}$.
\end{theorem}

\begin{proof}
Let $D$ be a $t$-time distinguisher that has success $\epsilon$ in the unlinkability scenario. We construct a distinguisher $\underline{D}$ for $F$ as follows. Given access to an oracle $\varphi(\cdot)$ the distinguisher $\underline{D}^{\varphi(\cdot)}$
proceeds as follows:
\begin{enumerate}
\item Simulates $b\gets D^{\mathcal{O}^{\varphi}}$, where the oracle calls are simulated as follows:
\begin{itemize}
\item $\mathcal{O}^{\varphi}(\mathsf{gen};\iota)$ -- If $\iota\in I$ then return $\bot$. Otherwise, set $I\gets I \cup \{\iota\}$ and return $f(\varphi(\iota))$
\item $\mathcal{O}^{\varphi}(\mathsf{sig};\iota,m)$ -- If $\iota\not\in I$ then return $\bot$. Otherwise, return $S(\varphi(\iota);m)$
\end{itemize}
\item Returns $b$
\end{enumerate}

If $\varphi(\cdot)=F_k(\cdot)$, then the oracle $\mathcal{O}^\varphi$ is equivalent to  $\mathcal{O}^{\tilde{\mathsf{S}}}_k$, because then:
\begin{itemize}
\item $\mathcal{O}^\varphi(\mathsf{gen};\iota) = \mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{gen};\iota)$ as $f(\varphi(\iota)) = f(F_k(\iota))=G_p(k,\iota)$, and
\item
$\mathcal{O}^\varphi(\mathsf{sig};\iota,m) = \mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{sig};\iota,m)$
due to $S(\varphi(\iota);m)=S(F_k(\iota);m)=S'(k;\iota,m)$
\end{itemize}
If $\varphi(\cdot)=\Phi(\cdot)$, then the oracle $\mathcal{O}^\varphi$ is equivalent to  $\mathcal{O}^{\tilde{\mathsf{S}}}$, because then:
\begin{itemize}
\item $\mathcal{O}^\varphi(\mathsf{gen};\iota) = \mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{gen};\iota)$
because
due to lazy sampling technique, computing $f(\varphi(\iota)) = f(\Phi(\iota))$
is equivalent to $k_\iota\gets K\equiv k_\iota\gets G_s$ and returning
$X_\iota = G_p(k_\iota,\iota)$
\item
$\mathcal{O}^\varphi(\mathsf{sig};\iota,m) = \mathcal{O}^{\tilde{\mathsf{S}}}_k(\mathsf{sig};\iota,m)$
due to $S(\varphi(\iota);m)=S(\Phi(\iota);m)=S'(k_\iota;\iota,m)$ in case $k_\iota$ was a saved value during lazy sampling and hence $\Phi(\iota)=k_\iota$.
\end{itemize}
Therefore, the unlinkability scenario with $D$ is equivalent to the PRF scenario with $\underline{D}$ and
hence, the success of $\underline{D}$ in the PRF-scenario is $\epsilon$. As the computational time overhead function is $\tau(t) = (1+\max\{t_\mathsf{gen},t_\mathsf{sig}\})\cdot t$, the statement of the theorem follows.
\end{proof}

\begin{theorem}
If $\mathsf{S}=(G,S,V)$ is a MPK-friendly signature scheme that is $s$-secure EF-CKMA and its transformed scheme $\tilde{S}=\mathsf{S}^F=(G_s,G_p,S',V)$ is $s$-secure unlinkable, then $\tilde{S}$ is $s'$-secure EF-CKMA, where $s'(\epsilon) = s(\epsilon/2)$.
\end{theorem}

\begin{proof}
Let $A^\mathcal{O}$ be a $t$-time oracle adversary that succeeds with probability $\epsilon$ in the EF-CKMA scenario. We construct a distinguisher $D^\mathcal{O}$ for unlinkability and an EF-CKMA adversary $A^\mathcal{O}_\mathsf{ckma}$ for $\mathsf{S}$ as follows:
\begin{itemize}
\item $D^\mathcal{O}$ simulates $(X,\iota,m,\sigma)\gets A^{\mathcal{O}}$ and returns 1 iff $A$ is successful.
\item $A_\mathsf{ckma}^\mathcal{O}$ also simulates $(X,\iota,m,\sigma)\gets A^{\mathcal{O}}$ and returns $(X,\iota,m,\sigma)$.
\end{itemize}
In the EF-CKMA scenario, $k\gets K \equiv k\gets G_s$ is picked uniformly at random and $(X,\iota,m,\sigma)\gets A^{\mathcal{O}^{\tilde{\mathsf{S}}}_k}$ produces existential forgery with probability $\epsilon$. Hence, $\mathsf{Pr}[1\gets D^{\mathcal{O}^{\tilde{\mathsf{S}}}_k}]=\epsilon$. Let $\epsilon'$ be the probability that $(X,\iota,m,\sigma)\gets A^{\mathcal{O}^{\tilde{\mathcal{S}}}}$
produces existential forgery. Hence,
$\mathsf{Pr}[1\gets D^{\mathcal{O}^{\tilde{\mathsf{S}}}}]=\epsilon'$
and the success of $D$ in the unlinkability scenario is $\epsilon_\mathsf{unl}=|\epsilon-\epsilon'|$.
Note also that the oracles $\mathcal{O}^{\tilde{\mathsf{S}}}$ (from Def.~\ref{def:unlinkability}) and $\mathcal{O}^{\mathsf{S}}$ (from Def.~\ref{def:efckma-ordinary}) are equivalent because:
\begin{itemize}
\item $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{gen};\iota) = \mathcal{O}^{\mathsf{S}}(\mathsf{gen};\iota)$ as the scenario
[$k_\iota \gets G_s, X_\iota \gets G_p(k_\iota)$, Return $X_\iota$]
is equivalent to the scenario
[$(x_\iota, X_\iota)\gets G$, Return $X_\iota$].
\item $\mathcal{O}^{\tilde{\mathsf{S}}}(\mathsf{sig};\iota,m) = \mathcal{O}^{\mathsf{S}}(\mathsf{sig};\iota,m)$ as $S'(k_\iota;\iota,m)=S(F_{k_\iota}(\iota);m)=S(x_\iota;m)$.
\end{itemize}
Hence, $A_\mathsf{ckma}^{\mathcal{O}^\mathsf{S}}$
succeeds in the EF-CKMA scenario with probability $\epsilon_\mathsf{ckma}=\epsilon'$.
Therefore, $\epsilon \le \epsilon_\mathsf{unl}+ \epsilon_\mathsf{kcma}$. As the construction of $D$ and $A_\mathsf{ckma}$ involves no computational time overhead, we conclude that
$\tilde{\mathsf{S}}$ is $s'$-secure EF-CKMA with $s'(\epsilon) = s(\epsilon/2)$.
\end{proof}

\subsubsection{Remarks on Practical Implementation}

The main tool in the construction is the pseudo-random function family $F$ and hence the security of the scheme directly depends on the security of $F$ as a PRF.

For the ECDSA and EdDSA with groups the order $q$ of which is much less than $2^{512}$ we may apply the HMAC construction \cite{BeCK96} as follows:
\[
F_k(\iota) = \mathsf{Int}(\mathsf{HMAC}_{\mathsf{sha512}} (k;\iota)) \mod q
\]
where $\mathsf{Int}\colon \{0,1\}^{512}\rightarrow \mathbb{Z}_{2^{512}}$ converts bitstrings to non-negative integers, $k\gets K=\{0,1\}^{m}$, and $\iota\in\mathbb{I}=\{0,1\}^{64}$.
If
%$m$ is sufficiently large (say $m=512$) and
$q\ll 2^{512}$, then the output distribution
of $F_k(\cdot)$ is almost as indistinguishable
from the uniform distribution $U_q$ on $\mathbb{Z}_{q}$ as the output distribution of $\mathsf{HMAC}_{\mathsf{sha512}} (k;\cdot)$ from the uniform distribution $U_{2^{512}}$ on $\{0,1\}^{512}$
because the statistical distance between
$U_q$ and the distribution  $\mathsf{Int}(U_{2^{512}})\!\!\mod q$ has an upper bound $\frac{q}{2^{513}}$.

In \cite{Bell15}, Bellare proved that HMAC is a PRF if the compression function (of the hash function) is a PRF, which is a good practical security guarantee since no efficient attacks are known against the PRF-security of the compression function.

\subsection{A Solution for ECDSA}

Unlike the rest of the paper which is not signature scheme specific, we are assuming the ECDSA signature scheme\cite{ecdsa} in the following subsections, and use the ECDSA, DH specific notation.

\subsubsection{Interactive Protocol}

The recipient holds a persistent keypair $(d, P)$ where $P = d \cdot G$ with generator $G$ and order $n$. For each transaction, the recipient generates an ephemeral blinding factor $r \gets \mathbb{Z}_n$ and derives a transaction-specific public key $P' = (d + r) \cdot G$. The protocol is shown in Figure~\ref{fig:protocol1}.


\begin{figure}[!htb]
\centering
\fbox{
\begin{minipage}{0.9\textwidth}

\underline{Setup:} Recipient holds persistent keypair $(d, P)$ where $P = d \cdot G$

\vspace{3mm}
\begin{tabular}{lcl}
\textbf{Sender} & & \textbf{Recipient}\\
\hline
\\[-2mm]
  & &$r \stackrel{\$}{\gets} \mathbb{Z}_n$  \\
  & & $P_{tx} \gets (d + r) \cdot G$  \\
  & & $R \gets r \cdot G$  \\
  & $\xleftarrow{\hspace{1cm} (P_{tx}, R) \hspace{1cm}}$ & \\
$\mathsf{tx} \gets \{P_{tx}, R, \ldots\}$  & &  \\
  & $\xrightarrow{\hspace{1.5cm} \mathsf{tx} \hspace{1.5cm}}$ & \\
  & & $r' \gets \mathcal{H}(d \,||\, R)$ \\
  & & $d_{tx} \gets d + r' \bmod n$ \\
  & & $\sigma \gets \mathsf{Sign}(d_{tx}; \mathsf{tx}_{next})$ \\
\end{tabular}
\end{minipage}
}
\caption{Interactive protocol for generating unlinkable ECDSA public keys.}
\label{fig:protocol1}
\end{figure}

The recipient maintains only the persistent secret $d$ and derives ephemeral signing keys deterministically from data field $R$, included with the transaction. When spending the token, the recipient reconstructs the blinding factor $r' = H(d \,||\, R)$ and derives the private key $d' = d + r' \bmod n$ corresponding to $P'$.

\subsubsection{Non-Interactive Protocol}\label{sec:non-interactive-protocol}

For applications requiring persistent public keys as ``addresses'', or non-interactive operation, the parties can create the blinded public key using Diffie-Hellman key exchange. The recipient publishes a persistent public key $P = d \cdot G$. The protocol is shown in Figure~\ref{fig:protocol3}.

The key challenge in non-interactive protocols is protecting against malicious senders who might choose predictable ephemeral keys $r$ or leak them to compromise transaction unlinkability. The secure construction addresses this by binding the blinding factor to both the shared Diffie-Hellman secret and public transaction data.

\begin{figure}[ht]
\centering
\fbox{
\begin{minipage}{0.95\textwidth}

\underline{Setup:}
Recipient has persistent keypair $(d, P = d \cdot G)$ and publishes $P$

\vspace{3mm}
\begin{tabular}{lcl}
\textbf{Sender} & & \textbf{Recipient} \\
\hline
\\[-2mm]
$r \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$ & & \\
$R \leftarrow r \cdot G$ & & \\
$s \leftarrow \mathcal{H}_1(r \cdot P \,||\, R \,||\, \mathsf{tx}_{prev})$ & & \\
$P_{tx} \leftarrow P + s \cdot G$ & & \\
$\mathsf{tx} \leftarrow \{P_{tx}, R, \dots\}$ & & \\
& $\xrightarrow{\hspace{.6cm} \mathsf{tx} \hspace{.6cm}}$ & \\[3mm]
& & \textbf{if} $R = \mathcal{O}$ \textbf{then abort} \\
& & $s' \leftarrow \mathcal{H}_1(d \cdot R \,||\, R \,||\, \mathsf{tx}_{prev})$ \\
& & \textbf{if} $P + s' \cdot G \neq P_{tx}$ \textbf{then abort} \\
& & $d_{tx} \leftarrow d + s' \bmod n$ \\
& & \textit{Sign next transaction using} $d_{tx}$ \\
\end{tabular}
\end{minipage}
}
\caption{Non-interactive protocol secure against malicious sender.}
\label{fig:protocol3}
\end{figure}

The sender generates an ephemeral keypair $(r, R = r \cdot G)$ and computes a Diffie-Hellman shared secret $r \cdot P$. The blinding factor $s$ is derived by hashing the shared secret together with the ephemeral public key $R$ and the previous transaction identifier $\mathsf{tx}_{prev}$:
$$s = \mathcal{H}_1(r \cdot P \,||\, R \,||\, \mathsf{tx}_{prev})$$

The transaction-specific public key is computed as $P_{tx} = P + s \cdot G$, and both $P_{tx}$ and $R$ are included in the transaction. Upon receiving the transaction, the recipient:
\begin{enumerate}
\item Verifies that $R \neq \mathcal{O}$ (the point at infinity) to prevent trivial attacks
\item Computes the same shared secret $d \cdot R = r \cdot P$ using their persistent private key
\item Derives $s' = \mathcal{H}_1(d \cdot R \,||\, R \,||\, \mathsf{tx}_{prev})$ and verifies that $P + s' \cdot G = P_{tx}$
\item Computes the transaction-specific private key $d_{tx} = d + s' \bmod n$ for signing the next transaction
\end{enumerate}

By including both $R$ and $\mathsf{tx}_{prev}$ in the hash input, the protocol ensures that:
\begin{itemize}
\item Even if the sender chooses a predictable $r$, the blinding factor $s$ depends on the hash function output and remains unpredictable to external observers
\item The recipient can verify that the sender correctly computed $P_{tx}$ without learning $r$
\item Each transaction uses a unique blinding factor (assuming $\mathsf{tx}_{prev}$ is always unique), preventing linkability even if the sender reuses the same $r$ across different transactions
\end{itemize}

We assume that $\mathsf{tx}_{prev}$ is always unique, as a malicious sender reusing the exact $(r, \mathsf{tx}_{prev})$ pair could break unlinkability. In practice, $\mathsf{tx}_{prev}$ can be the hash of the previous transaction or a timestamp with sufficient granularity.


\subsubsection{Desired Privacy Properties:}

\begin{enumerate}
\item \textbf{Transaction Identity Unlinkability:}
For any two transactions $\mathsf{tx}_i, \mathsf{tx}_j$ with $i \neq j$:
$$\text{Dist}[(P_{tx,i}, R_i)] \approx_c \text{Dist}[(U_1, U_2)]$$
where $U_1, U_2 \stackrel{\$}{\leftarrow} \mathbb{G}$ are uniform random group elements.

\textit{Informally:} The ownership-related fields in each transaction appear as uniformly random data. The pair $(P_{tx}, R)$ in any transaction is computationally indistinguishable from two random group elements, making all transactions unlinkable to each other and to any recipient addresses.

\item \textbf{Forward Privacy:}
Given $d_{tx,i} = d_i + \mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$:
$$\Pr\left[\mathcal{A}(d_{tx,i}, \{\mathsf{tx}_j\}_{j=1}^n) \rightarrow d_i\right] \leq \text{negl}(\lambda)$$

\textit{Informally:} If a transaction-specific private key $d_{tx,i}$ is compromised (e.g., leaked or extracted from a device), the adversary cannot recover the recipient's persistent private key $d_i$. This ensures that past key exposures do not compromise the recipient's persistent identity or future transactions.
\end{enumerate}

\textbf{Remark:} Transaction Identity Unlinkability implies several important corollaries:
\begin{itemize}
\item \emph{Address Unlinkability:} An adversary observing a transaction cannot determine which of two candidate recipients it was sent to, beyond random guessing. This follows immediately since if $(P_{tx}, R)$ is pseudorandom, it reveals no information about the underlying persistent address $P$.

\item \emph{Recipient Unlinkability:} An adversary observing multiple transactions cannot determine which transactions belong to the same recipient. Even when a recipient reuses their persistent public key $P$ across multiple transactions, the resulting transaction-specific keys appear independent and uniformly random.
\end{itemize}

\subsubsection{Cryptographic Assumptions}

For the privacy proofs, we require the following standard cryptographic assumptions in the elliptic curve group $\mathbb{G}$ of prime order $n$ with generator $G$:

\begin{definition}[Decisional Diffie-Hellman (DDH)]
The DDH problem is $S$-hard in $\mathbb{G}$ if it has $S$ as a security profile in the following distinguishing scenario:
\begin{enumerate}
\item Sample $a, b, c \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$ and $d \stackrel{\$}{\leftarrow} \{0,1\}$
\item If $d = 0$: set $T \leftarrow (a \cdot G, b \cdot G, ab \cdot G)$
\item If $d = 1$: set $T \leftarrow (a \cdot G, b \cdot G, c \cdot G)$
\item $d' \gets \mathcal{A}(T)$
\item The attack is successful iff $d' = d$
\end{enumerate}
The advantage is $\text{Adv}^{\text{DDH}}_{\mathcal{A}} = \left|\Pr[d' = d] - \frac{1}{2}\right|$.
\end{definition}

\begin{definition}[Discrete Logarithm (DL)]
The DL problem is $S$-hard in $\mathbb{G}$ if it has $S$ as a security profile in the following attack scenario:
\begin{enumerate}
\item $x \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$, $X \leftarrow x \cdot G$
\item $x' \gets \mathcal{A}(X)$
\item The attack is successful iff $x' = x$
\end{enumerate}
\end{definition}

We model $\mathcal{H}_1 \colon \mathbb{G} \times \mathbb{G} \times \mathcal{M} \to \mathbb{Z}_n$ as a hash function with standard collision-resistance and additional properties suitable for key derivation.

\subsubsection{Privacy Proofs}

\begin{theorem}[Transaction Identity Unlinkability]
\label{thm:transaction-unlinkability}
If the DDH problem is $S$-hard in $\mathbb{G}$ and $\mathcal{H}_1$ is modeled as a random oracle, then the protocol in Fig.~\ref{fig:protocol3} satisfies transaction identity unlinkability. Specifically, for any two transactions $\mathsf{tx}_i, \mathsf{tx}_j$ with $i \neq j$:
$$\text{Dist}[(P_{tx,i}, R_i)] \approx_c \text{Dist}[(U_1, U_2)]$$
where $U_1, U_2 \stackrel{\$}{\leftarrow} \mathbb{G}$ are uniformly random, with distinguishing advantage at most $\text{Adv}^{\text{DDH}}_{\mathcal{A}} + \frac{q_H}{n}$ where $q_H$ is the number of hash queries.
\end{theorem}

\begin{proof}
For transaction $\mathsf{tx}_i$, the sender chooses $r_i \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$ and computes:
\begin{align*}
R_i &= r_i \cdot G \\
s_i &= \mathcal{H}_1(r_i \cdot P_i \,||\, R_i \,||\, \mathsf{tx}_{i-1}) \\
P_{tx,i} &= P_i + s_i \cdot G
\end{align*}

We use a game-based argument to show that $(P_{tx,i}, R_i)$ is indistinguishable from $(U_1, U_2)$ where $U_1, U_2 \stackrel{\$}{\leftarrow} \mathbb{G}$.

\textbf{Game 0:} The real transaction generation process as described above.

\textbf{Game 1:} Replace $s_i = \mathcal{H}_1(r_i \cdot P_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$ with a uniformly random $s_i \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$.

\noindent\textit{Claim:} $|\Pr[\text{Game 0}] - \Pr[\text{Game 1}]| \leq \text{Adv}^{\text{DDH}}_{\mathcal{A}} + \frac{q_H}{n}$.

Consider the tuple $(P_i, R_i, r_i \cdot P_i) = (d_i \cdot G, r_i \cdot G, r_i d_i \cdot G)$. Under the DDH assumption, this is computationally indistinguishable from $(d_i \cdot G, r_i \cdot G, c \cdot G)$ where $c \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$. Since $\mathcal{H}_1$ is modeled as a random oracle and $\mathsf{tx}_{i-1}$ is unique (by assumption), if the adversary does not query $\mathcal{H}_1(r_i \cdot P_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$, the value $s_i$ is uniformly random. The probability of guessing the correct input is at most $\frac{q_H}{n}$.

\textbf{Game 1 Analysis:} Since $r_i$ is chosen uniformly at random, $R_i = r_i \cdot G$ is uniformly distributed in $\mathbb{G}$. Given that $s_i \stackrel{\$}{\leftarrow} \mathbb{Z}_n^*$ is uniformly random and independent, $P_{tx,i} = P_i + s_i \cdot G$ is uniformly distributed in $\mathbb{G}$, since adding a uniformly random scalar times the generator to any group element yields a uniformly random element.

Therefore, in Game 1, $(P_{tx,i}, R_i)$ has the same distribution as two independent uniformly random group elements $(U_1, U_2)$.

Since this holds for each transaction independently (with fresh randomness $r_i$ for each transaction), the identity data in all transactions is unlinkable.
\end{proof}

\begin{theorem}[Forward Privacy]
\label{thm:forward-privacy}
If the discrete logarithm problem is $S$-hard in $\mathbb{G}$ and $\mathcal{H}_1$ is modeled as a random oracle, then for any PPT adversary $\mathcal{A}$:
$$\Pr\left[\mathcal{A}(d_{tx,i}, \{\mathsf{tx}_j\}_{j=1}^n) \rightarrow d_i\right] \leq \text{Adv}^{\text{DL}}_{\mathcal{A}} + \frac{q_H}{n}$$
where $d_{tx,i} = d_i + s_i \bmod n$ and $s_i = \mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$.
\end{theorem}

\begin{proof}
The recipient's transaction-specific private key is:
$$d_{tx,i} = d_i + s_i \bmod n$$
where $s_i = \mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$.

To recover $d_i$ from $d_{tx,i}$, the adversary must compute $s_i$, since:
$$d_i = d_{tx,i} - s_i \bmod n$$

Computing $s_i$ requires evaluating $\mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$, which in turn requires computing the shared secret $d_i \cdot R_i = d_i r_i \cdot G$.

The adversary observes:
\begin{itemize}
\item $R_i = r_i \cdot G$ (from the transaction)
\item $P_i = d_i \cdot G$ (possibly inferred or public, though unlinkable by Theorem~\ref{thm:transaction-unlinkability})
\item $d_{tx,i}$ (the leaked transaction key)
\end{itemize}

\textbf{Case 1:} The adversary does not query $\mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$.

Since $\mathcal{H}_1$ is a random oracle, without querying the correct input, $s_i$ appears uniformly random in $\mathbb{Z}_n$. Given $d_{tx,i} = d_i + s_i \bmod n$ where $s_i$ is unknown and uniform, the value $d_i$ is information-theoretically hidden. The adversary can succeed only by guessing among $q_H$ hash queries, with probability at most $\frac{q_H}{n}$.

\textbf{Case 2:} The adversary queries $\mathcal{H}_1(d_i \cdot R_i \,||\, R_i \,||\, \mathsf{tx}_{i-1})$.

To make this query, the adversary must compute $d_i \cdot R_i = d_i r_i \cdot G$ from $P_i = d_i \cdot G$ and $R_i = r_i \cdot G$. This is precisely the Computational Diffie-Hellman (CDH) problem, which is at least as hard as the discrete logarithm problem. If the adversary can compute $d_i \cdot R_i$, they can use the discrete logarithm oracle to extract $d_i$ from $P_i$ (or $r_i$ from $R_i$), succeeding with probability at most $\text{Adv}^{\text{DL}}_{\mathcal{A}}$.

Combining both cases, the adversary's advantage in recovering $d_i$ is bounded by $\text{Adv}^{\text{DL}}_{\mathcal{A}} + \frac{q_H}{n}$, which is negligible.
\end{proof}

\subsubsection{Remarks on Standard Model}

The proofs above use $\mathcal{H}_1$ as a random oracle. To achieve standard model security, we propose the following adjustment:

\textbf{Adjustment:} Replace the hash function $\mathcal{H}_1$ with a key derivation function (KDF) based on a pseudorandom function (PRF) family $\{f_k\}_{k \in \mathcal{K}}$ combined with randomness extraction. Specifically:
\begin{enumerate}
\item Use a randomness extractor $\text{Ext} \colon \mathbb{G} \to \{0,1\}^\lambda$ based on a strong randomness extractor (e.g., leftmost bits of the $x$-coordinate under suitable encoding).
\item Define $s \leftarrow \text{PRF}(\text{Ext}(r \cdot P), R \,||\, \mathsf{tx}_{prev})$ where PRF is a pseudorandom function.
\end{enumerate}

Under the DDH assumption, the value $r \cdot P$ is pseudorandom (given $r \cdot G$ and $P$), and thus $\text{Ext}(r \cdot P)$ serves as a pseudorandom key for the PRF. The PRF output is then pseudorandom, providing similar guarantees to the random oracle model.

With this adjustment, the proofs can be adapted to the standard model by replacing random oracle arguments with PRF indistinguishability under DDH, at the cost of slightly more complex security reductions and stronger assumptions on the randomness extractor properties.
